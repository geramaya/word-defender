<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Defender vs. The Psycho Word Hunter</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            background: #0a0a0a;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Inter', sans-serif;
        }

        .container {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: linear-gradient(135deg, #111111 0%, #000000 100%);
            border: none;
            overflow: hidden;
        }

        /* Star glow effects */
        .star-glow {
            filter: drop-shadow(0 0 4px white) drop-shadow(0 0 8px white) drop-shadow(0 0 12px white);
        }
        
        .star-sparkle {
            filter: drop-shadow(0 0 6px white) drop-shadow(0 0 12px white) drop-shadow(0 0 18px white) drop-shadow(0 0 24px rgba(255,255,255,0.8));
        }

        .hello {
            position: absolute;
            font-family: 'Inter', sans-serif;
            user-select: none;
            pointer-events: auto;
            cursor: grab;
            transition: text-shadow 0.3s ease;
            will-change: transform;
            backface-visibility: hidden;
            transform-style: preserve-3d;
        }
        
        .hello:active {
            cursor: grabbing;
        }
        
        .hello:hover {
            filter: brightness(1.2);
        }
        
        .hello.glowing {
            text-shadow: 0 0 20px currentColor, 0 0 40px currentColor, 0 0 60px currentColor;
        }

        .hello.targeted {
            text-shadow: 0 0 15px #ff4444, 0 0 30px #ff4444, 0 0 45px #ff4444;
            animation: targetedPulse 0.8s ease-in-out infinite alternate;
        }

        @keyframes targetedPulse {
            0% { text-shadow: 0 0 15px #ff4444, 0 0 30px #ff4444, 0 0 45px #ff4444; }
            100% { text-shadow: 0 0 25px #ff4444, 0 0 50px #ff4444, 0 0 75px #ff4444; }
        }

        .spaceship {
            position: absolute;
            width: 50px;
            height: 50px;
            z-index: 1000;
            pointer-events: none;
            transition: transform 0.3s ease-out;
        }

        .booster-flame {
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            width: 8px;
            height: 20px;
            background: linear-gradient(to top, #ff4444, #ffff44, #ff8844);
            border-radius: 50% 50% 0 0;
            opacity: 0;
            animation: boosterFlame 0.5s ease-out;
        }

        @keyframes boosterFlame {
            0% { opacity: 0; height: 0px; }
            30% { opacity: 1; height: 25px; }
            100% { opacity: 0; height: 15px; }
        }

        .laser {
            position: absolute;
            width: 12px;
            height: 12px;
            background: radial-gradient(circle, #ffff00 0%, #ff4400 50%, #ff0000 100%);
            border-radius: 50%;
            border: 2px solid #ffffff;
            box-shadow: 
                0 0 15px #ff4400,
                0 0 30px #ff4400,
                0 0 45px rgba(255, 68, 0, 0.8),
                inset 0 0 6px rgba(255, 255, 255, 0.6);
            pointer-events: none;
            z-index: 999;
            animation: projectilePulse 0.2s ease-in-out infinite alternate;
        }

        @keyframes projectilePulse {
            0% { 
                transform: scale(1);
                box-shadow: 
                    0 0 15px #ff4400,
                    0 0 30px #ff4400,
                    0 0 45px rgba(255, 68, 0, 0.8),
                    inset 0 0 6px rgba(255, 255, 255, 0.6);
            }
            100% { 
                transform: scale(1.2);
                box-shadow: 
                    0 0 20px #ff4400,
                    0 0 40px #ff4400,
                    0 0 60px rgba(255, 68, 0, 1.0),
                    inset 0 0 8px rgba(255, 255, 255, 0.8);
            }
        }

        .ultra-laser {
            width: 18px;
            height: 18px;
            background: radial-gradient(circle, #aa44ff 0%, #6600aa 50%, #440088 100%);
            border: 3px solid #ffffff;
            box-shadow: 
                0 0 20px #aa44ff,
                0 0 40px #aa44ff,
                0 0 60px rgba(170, 68, 255, 0.8),
                inset 0 0 8px rgba(255, 255, 255, 0.6);
            animation: ultraProjectilePulse 0.15s ease-in-out infinite alternate;
        }

        @keyframes ultraProjectilePulse {
            0% { 
                transform: scale(1);
                box-shadow: 
                    0 0 20px #aa44ff,
                    0 0 40px #aa44ff,
                    0 0 60px rgba(170, 68, 255, 0.8),
                    inset 0 0 8px rgba(255, 255, 255, 0.6);
            }
            100% { 
                transform: scale(1.3);
                box-shadow: 
                    0 0 30px #aa44ff,
                    0 0 60px #aa44ff,
                    0 0 90px rgba(170, 68, 255, 1.0),
                    inset 0 0 12px rgba(255, 255, 255, 0.8);
            }
        }

        .explosion-particle {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 998;
            box-shadow: 0 0 6px currentColor;
        }

        .restart-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #4488ff, #66aaff);
            color: white;
            border: none;
            padding: 20px 40px;
            font-size: 24px;
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 8px 25px rgba(68, 136, 255, 0.3);
            transition: all 0.3s ease;
            z-index: 1001;
            animation: pulseGlow 2s ease-in-out infinite alternate;
        }

        .restart-button:hover {
            transform: translate(-50%, -50%) scale(1.05);
            box-shadow: 0 12px 35px rgba(68, 136, 255, 0.4);
        }

        .restart-button:active {
            transform: translate(-50%, -50%) scale(0.95);
        }

        @keyframes pulseGlow {
            0% { box-shadow: 0 8px 25px rgba(68, 136, 255, 0.3); }
            100% { box-shadow: 0 8px 25px rgba(68, 136, 255, 0.6), 0 0 20px rgba(68, 136, 255, 0.2); }
        }

        .info-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(5px);
        }

        .info-box {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            border: 2px solid #4488ff;
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            text-align: center;
            color: white;
            font-family: 'Inter', sans-serif;
            box-shadow: 0 20px 60px rgba(68, 136, 255, 0.3);
        }

        .info-box h1 {
            font-size: 32px;
            font-weight: 800;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #4488ff, #66aaff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .info-box p {
            font-size: 18px;
            line-height: 1.6;
            margin-bottom: 15px;
            opacity: 0.9;
        }

        .info-box .highlight {
            color: #ff4444;
            font-weight: 600;
        }

        .start-button {
            background: linear-gradient(45deg, #4488ff, #66aaff);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 22px;
            font-family: 'Inter', sans-serif;
            font-weight: 700;
            border-radius: 12px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 8px 25px rgba(68, 136, 255, 0.4);
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .start-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(68, 136, 255, 0.5);
        }

        .start-button:active {
            transform: translateY(0);
        }

        .player-name-input {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #4488ff;
            border-radius: 8px;
            padding: 12px 20px;
            font-size: 18px;
            font-family: 'Inter', sans-serif;
            color: white;
            text-align: center;
            margin: 20px 0;
            width: 300px;
            backdrop-filter: blur(5px);
            outline: none;
        }

        .player-name-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .player-name-input:focus {
            border-color: #66aaff;
            box-shadow: 0 0 20px rgba(68, 136, 255, 0.3);
        }

        .error-message {
            color: #ff4444;
            font-size: 14px;
            margin-top: 10px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .error-message.show {
            opacity: 1;
        }

        .radar-ping {
            position: absolute;
            border: 2px solid #ff4444;
            border-radius: 50%;
            pointer-events: none;
            z-index: 997;
            animation: radarPing 0.5s ease-out infinite;
        }

        @keyframes radarPing {
            0% { 
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 1;
                border-width: 3px;
            }
            100% { 
                transform: translate(-50%, -50%) scale(2);
                opacity: 0;
                border-width: 1px;
            }
        }

        .game-ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 60px; /* Höhe der Leiste */
            background: linear-gradient(180deg, rgba(10, 10, 10, 0.95) 0%, rgba(10, 10, 10, 0.8) 100%);
            border-bottom: 2px solid rgba(68, 136, 255, 0.6);
            box-shadow: 0 4px 30px rgba(68, 136, 255, 0.2);
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 1500;
            padding: 0 20px;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            color: white;
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            font-size: 16px;
        }

        .ui-element {
            background: none;
            border: none;
            padding: 5px 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .words-remaining {
            color: #66aaff;
        }

        .survival-time {
            color: #ffaa44;
        }

        .current-score {
            color: #44ff88;
        }

        .defended-counter {
            color: #ff9944;
        }

        .shield-system {
            color: #44ffaa;
        }
        
        .spaceship-aggression {
            color: #ff6644;
        }
        
        .aggression-level {
            font-weight: 700;
            transition: color 0.3s ease;
        }
        
        .aggression-level.calm { color: #44ff88; }
        .aggression-level.alert { color: #ffaa44; }
        .aggression-level.aggressive { color: #ff6644; }
        .aggression-level.hunting { color: #ff4444; animation: huntingPulse 0.6s ease-in-out infinite alternate; }
        
        @keyframes huntingPulse {
            0% { color: #ff4444; text-shadow: 0 0 10px #ff4444; }
            100% { color: #ff8888; text-shadow: 0 0 20px #ff4444; }
        }
        
        .emergency-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 500;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        .emergency-overlay.active {
            opacity: 1;
        }
        
        .emergency-border {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 8px solid #ff4444;
            box-shadow: inset 0 0 50px rgba(255, 68, 68, 0.3);
            animation: emergencyPulse 1.5s ease-in-out infinite alternate;
        }
        
        @keyframes emergencyPulse {
            0% { 
                border-color: #ff4444;
                box-shadow: inset 0 0 50px rgba(255, 68, 68, 0.3);
            }
            100% { 
                border-color: #ff8888;
                box-shadow: inset 0 0 80px rgba(255, 68, 68, 0.5);
            }
        }

        .shield-counter {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-bottom: 5px;
        }

        .shield-cooldown {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
        }

        .cooldown-bar {
            width: 100px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .cooldown-bar::after {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: var(--progress, 0%);
            background: linear-gradient(90deg, #44ffaa, #66ddaa);
            border-radius: 4px;
            transition: width 0.1s ease-out;
        }

        .cooldown-text {
            font-size: 14px;
            color: #aaffcc;
            min-width: 25px;
        }

        /* Space Beacon Mine System */
        .space-beacon {
            position: absolute;
            width: 24px;
            height: 24px;
            background: radial-gradient(circle, #ff6b47 0%, #ff3838 40%, #cc0000 70%, #660000 100%);
            border-radius: 50%;
            border: 3px solid #ffaa44;
            box-shadow: 
                0 0 15px #ff6b47,
                0 0 30px #ff6b47,
                0 0 45px rgba(255, 107, 71, 0.7),
                inset 0 0 8px rgba(255, 255, 255, 0.3);
            z-index: 100;
            animation: beaconPulse 1.5s ease-in-out infinite;
        }

        .space-beacon::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 120px;
            height: 120px;
            border: 2px solid rgba(255, 107, 71, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: beaconRadiusBlink 1s ease-in-out infinite;
        }

        .space-beacon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            background: radial-gradient(circle, #ffff88 0%, #ffaa44 100%);
            border-radius: 50%;
            border: 1px solid #ffffff;
            transform: translate(-50%, -50%);
            animation: beaconCore 0.8s ease-in-out infinite alternate;
        }

        .space-beacon.targeting {
            border-color: #ff3333;
            background: radial-gradient(circle, #ff4444 0%, #cc1111 40%, #880000 70%, #440000 100%);
            box-shadow: 
                0 0 20px #ff3333,
                0 0 40px #ff3333,
                0 0 60px rgba(255, 51, 51, 0.9),
                inset 0 0 12px rgba(255, 255, 255, 0.4);
            animation: beaconTargetingPulse 0.3s ease-in-out infinite;
        }

        .space-beacon.targeting::before {
            border-color: rgba(255, 51, 51, 0.8);
            animation: beaconTargetingRadius 0.5s ease-in-out infinite;
        }

        .space-beacon.targeting::after {
            background: radial-gradient(circle, #ffaaaa 0%, #ff6666 100%);
        }

        @keyframes beaconPulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 
                    0 0 15px #ff6b47,
                    0 0 30px #ff6b47,
                    0 0 45px rgba(255, 107, 71, 0.7),
                    inset 0 0 8px rgba(255, 255, 255, 0.3);
            }
            50% { 
                transform: scale(1.15);
                box-shadow: 
                    0 0 20px #ff6b47,
                    0 0 40px #ff6b47,
                    0 0 60px rgba(255, 107, 71, 0.9),
                    inset 0 0 12px rgba(255, 255, 255, 0.5);
            }
        }

        @keyframes beaconRadiusBlink {
            0%, 100% { 
                border-color: rgba(255, 107, 71, 0.2);
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.4;
            }
            25% { 
                border-color: rgba(255, 107, 71, 0.8);
                transform: translate(-50%, -50%) scale(1.02);
                opacity: 1;
            }
            50% { 
                border-color: rgba(255, 255, 68, 0.9);
                transform: translate(-50%, -50%) scale(1.05);
                opacity: 0.9;
            }
            75% { 
                border-color: rgba(255, 107, 71, 0.8);
                transform: translate(-50%, -50%) scale(1.02);
                opacity: 1;
            }
        }

        @keyframes beaconTargetingPulse {
            0%, 100% { 
                transform: scale(1.1);
                box-shadow: 
                    0 0 20px #ff3333,
                    0 0 40px #ff3333,
                    0 0 60px rgba(255, 51, 51, 0.9),
                    inset 0 0 12px rgba(255, 255, 255, 0.4);
            }
            50% { 
                transform: scale(1.25);
                box-shadow: 
                    0 0 30px #ff3333,
                    0 0 60px #ff3333,
                    0 0 90px rgba(255, 51, 51, 1.0),
                    inset 0 0 16px rgba(255, 255, 255, 0.6);
            }
        }

        @keyframes beaconTargetingRadius {
            0%, 100% { 
                border-color: rgba(255, 51, 51, 0.6);
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.8;
            }
            50% { 
                border-color: rgba(255, 255, 255, 1.0);
                transform: translate(-50%, -50%) scale(1.1);
                opacity: 1.0;
            }
        }

        @keyframes beaconCore {
            0% { 
                background: #ffff88;
                transform: translate(-50%, -50%) scale(1);
            }
            100% { 
                background: #ffaa44;
                transform: translate(-50%, -50%) scale(1.2);
            }
        }

        .beacon-explosion {
            position: absolute;
            width: 120px;
            height: 120px;
            background: radial-gradient(circle, #ffff88 0%, #ff6b47 30%, #ff3838 60%, transparent 100%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: beaconExplode 0.6s ease-out forwards;
            z-index: 200;
        }

        @keyframes beaconExplode {
            0% { 
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 1;
            }
            50% {
                transform: translate(-50%, -50%) scale(2);
                opacity: 0.8;
            }
            100% { 
                transform: translate(-50%, -50%) scale(3);
                opacity: 0;
            }
        }

        /* Floating Mine Threat System */
        .floating-mine {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #44ff44 0%, #228822 40%, #116611 70%, #004400 100%);
            border-radius: 50%;
            border: 3px solid #88ff88;
            box-shadow: 
                0 0 12px #44ff44,
                0 0 24px #44ff44,
                0 0 36px rgba(68, 255, 68, 0.6),
                inset 0 0 6px rgba(255, 255, 255, 0.4);
            z-index: 150;
            animation: floatingMinePulse 1.2s ease-in-out infinite;
            pointer-events: none;
            cursor: default;
        }

        .floating-mine::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            background: radial-gradient(circle, #ccffcc 0%, #88ff88 100%);
            border-radius: 50%;
            border: 1px solid #ffffff;
            transform: translate(-50%, -50%);
            animation: floatingMineCore 0.6s ease-in-out infinite alternate;
        }

        .floating-mine::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 160px;
            height: 160px;
            border: 2px solid rgba(68, 255, 68, 0.4);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: floatingMineRadius 1.5s ease-in-out infinite;
        }

        .floating-mine.targeted {
            border-color: #ff6666;
            background: radial-gradient(circle, #ff4444 0%, #cc2222 40%, #881111 70%, #440000 100%);
            box-shadow: 
                0 0 12px #ff4444,
                0 0 24px #ff4444,
                0 0 36px rgba(255, 68, 68, 0.8),
                inset 0 0 8px rgba(255, 255, 255, 0.3);
            animation: targetedMinePulse 0.4s ease-in-out infinite;
        }

        .floating-mine.targeted::before {
            background: radial-gradient(circle, #ffcccc 0%, #ffaaaa 100%);
        }

        @keyframes floatingMinePulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 
                    0 0 12px #44ff44,
                    0 0 24px #44ff44,
                    0 0 36px rgba(68, 255, 68, 0.6),
                    inset 0 0 6px rgba(255, 255, 255, 0.4);
            }
            50% { 
                transform: scale(1.1);
                box-shadow: 
                    0 0 16px #44ff44,
                    0 0 32px #44ff44,
                    0 0 48px rgba(68, 255, 68, 0.8),
                    inset 0 0 8px rgba(255, 255, 255, 0.6);
            }
        }

        @keyframes targetedMinePulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 
                    0 0 8px #ff4444,
                    0 0 16px #ff4444,
                    0 0 24px rgba(255, 68, 68, 0.6);
            }
            50% { 
                transform: scale(1.2);
                box-shadow: 
                    0 0 12px #ff4444,
                    0 0 24px #ff4444,
                    0 0 36px rgba(255, 68, 68, 0.8);
            }
        }

        @keyframes floatingMineRadius {
            0%, 100% { 
                border-color: rgba(68, 255, 68, 0.3);
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.5;
            }
            50% { 
                border-color: rgba(68, 255, 68, 0.7);
                transform: translate(-50%, -50%) scale(1.05);
                opacity: 0.8;
            }
        }

        @keyframes floatingMineCore {
            0% { 
                background: #88ff88;
                transform: translate(-50%, -50%) scale(1);
            }
            100% { 
                background: #aaffaa;
                transform: translate(-50%, -50%) scale(1.3);
            }
        }

        .shield-hint {
            font-size: 12px;
            color: #88ccaa;
            opacity: 0.8;
        }

        .shielded-word {
            box-shadow: 
                0 0 15px #4da6ff,
                0 0 25px #4da6ff,
                0 0 35px rgba(77, 166, 255, 0.5);
            animation: shield-pulse 2s infinite ease-in-out;
        }

        @keyframes shield-pulse {
            0%, 100% { 
                box-shadow: 
                    0 0 15px #4da6ff,
                    0 0 25px #4da6ff,
                    0 0 35px rgba(77, 166, 255, 0.5);
            }
            50% { 
                box-shadow: 
                    0 0 20px #66b3ff,
                    0 0 30px #66b3ff,
                    0 0 45px rgba(102, 179, 255, 0.6);
            }
        }

        .highscore-table {
            background: rgba(26, 26, 26, 0.95);
            border: 2px solid #4488ff;
            border-radius: 20px;
            padding: 30px;
            margin-top: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 20px 60px rgba(68, 136, 255, 0.3);
        }

        .highscore-table h2 {
            color: #66aaff;
            font-size: 24px;
            margin-bottom: 20px;
            text-align: center;
            background: linear-gradient(45deg, #4488ff, #66aaff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .highscore-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .highscore-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(68, 136, 255, 0.3);
            border-radius: 8px;
            color: white;
            font-size: 16px;
            gap: 20px;
        }

        .highscore-entry.current {
            background: rgba(68, 136, 255, 0.2);
            border-color: #4488ff;
            box-shadow: 0 0 15px rgba(68, 136, 255, 0.3);
        }

        .highscore-rank {
            font-weight: 700;
            color: #ffaa44;
            min-width: 40px;
            flex-shrink: 0;
        }

        .highscore-name {
            flex: 1;
            text-align: left;
            min-width: 120px;
        }

        .highscore-score {
            font-weight: 600;
            color: #44ff88;
            min-width: 90px;
            text-align: right;
            flex-shrink: 0;
        }

        .highscore-time {
            font-weight: 600;
            color: #66aaff;
            min-width: 70px;
            text-align: right;
            flex-shrink: 0;
        }
        /* Pulsar Endgame Mechanics */
        .pulsar {
            position: absolute;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 500;
            transform: translate(-50%, -50%);
        }

        .pulsar.phase1 {
            background: radial-gradient(circle, rgba(68, 136, 255, 0.8) 0%, rgba(68, 136, 255, 0.4) 40%, rgba(68, 136, 255, 0.1) 70%, transparent 100%);
            box-shadow: 
                0 0 40px rgba(68, 136, 255, 0.6),
                0 0 80px rgba(68, 136, 255, 0.4),
                0 0 120px rgba(68, 136, 255, 0.2);
            animation: pulsarBlue 2s ease-in-out infinite;
        }

        .pulsar.phase2 {
            background: radial-gradient(circle, rgba(255, 68, 68, 0.9) 0%, rgba(255, 68, 68, 0.5) 40%, rgba(255, 68, 68, 0.2) 70%, transparent 100%);
            box-shadow: 
                0 0 60px rgba(255, 68, 68, 0.8),
                0 0 120px rgba(255, 68, 68, 0.6),
                0 0 180px rgba(255, 68, 68, 0.4);
            animation: pulsarRed 1s ease-in-out infinite;
        }

        @keyframes pulsarBlue {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.8;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.3);
                opacity: 1;
            }
        }

        @keyframes pulsarRed {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1.1);
                opacity: 0.9;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.5);
                opacity: 1;
            }
        }

        .pulsar-wave {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            z-index: 499;
            transform: translate(-50%, -50%);
        }

        .pulsar-wave.phase1 {
            border: 3px solid rgba(68, 136, 255, 0.6);
            animation: waveExpand1 1.5s ease-out forwards;
        }

        .pulsar-wave.phase2 {
            border: 4px solid rgba(255, 68, 68, 0.8);
            animation: waveExpand2 1s ease-out forwards;
        }

        @keyframes waveExpand1 {
            0% {
                width: 120px;
                height: 120px;
                opacity: 1;
            }
            100% {
                width: 400px;
                height: 400px;
                opacity: 0;
            }
        }

        @keyframes waveExpand2 {
            0% {
                width: 120px;
                height: 120px;
                opacity: 1;
            }
            100% {
                width: 500px;
                height: 500px;
                opacity: 0;
            }
        }

    </style>
    <script>
        const PHI = 1.618033988749;
        const UI_BAR_HEIGHT = 60; // Muss mit der CSS-Höhe von .game-ui übereinstimmen
        let containerWidth = window.innerWidth;
        let containerHeight = window.innerHeight;
        
        let wordsData = [];
        let floatingTexts = [];
        let spaceshipShootTimer;
        let spaceshipController;
        let secondSpaceshipController = null;
        let restartButton = null;
        let gameStarted = false;
        let gameStartTime = 0;
        let radarPingInterval = null;
        
        // Global array for active homing projectiles
        let activeProjectiles = [];
        
        // Shield system
        let shieldCount = 3;
        let maxShields = 3;
        let shieldCooldown = 60000; // 60 seconds
        let lastShieldTime = 0;
        let protectedWords = new Set();
        
        // Beacon mine system
        let spaceBeacons = [];
        let maxBeacons = 3;
        let beaconDeploymentCounter = 0; // Track defenses for beacon deployment
        let nextBeaconAt = 4; // First beacon at 4th defense, then every 2nd
        
        // Floating mine system
        let floatingMines = [];
        let mineSpawnTimer = null;
        // Pulsar endgame system
        let pulsarElement = null;
        let pulsarPhase = 0; // 0 = inactive, 1 = phase1 (≤4 words), 2 = phase2 (≤2 words)
        let pulsarTimer = 0;
        let pulsarCycleTime = 1000; // 1 second for phase 1, 0.5 second for phase 2
        let pulsarCycleCount = 0;
        let pulsarActive = false; // Whether currently pulling words

        let mineSpawnInterval = 30000; // 30 seconds
        let mineLifespan = 10000; // 10 seconds
        
        // Scoring system
        let currentScore = 0;
        let consecutiveSuccessfulDefenses = 0;
        let attackInterval = 10000; // Start at 10 seconds
        let hasFirstAttackHappened = false;
        let defendedWordsCounter = 0;
        
        // Sound system
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function createBoosterSound() {
            // Create multiple oscillators for complex jet afterburner sound
            const osc1 = audioContext.createOscillator();
            const osc2 = audioContext.createOscillator();
            const osc3 = audioContext.createOscillator(); // Added high-pitched scream
            const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1, audioContext.sampleRate);
            const noiseSource = audioContext.createBufferSource();
            
            // Create noise for turbulent jet sound
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < noiseBuffer.length; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            noiseSource.buffer = noiseBuffer;
            noiseSource.loop = true;
            
            const gain1 = audioContext.createGain();
            const gain2 = audioContext.createGain();
            const gain3 = audioContext.createGain();
            const noiseGain = audioContext.createGain();
            const masterGain = audioContext.createGain();
            
            // Connect everything
            osc1.connect(gain1);
            osc2.connect(gain2);
            osc3.connect(gain3);
            noiseSource.connect(noiseGain);
            gain1.connect(masterGain);
            gain2.connect(masterGain);
            gain3.connect(masterGain);
            noiseGain.connect(masterGain);
            masterGain.connect(audioContext.destination);
            
            // Jet afterburner: explosive start, then fading rumble
            osc1.type = 'sawtooth';
            osc1.frequency.setValueAtTime(120, audioContext.currentTime);
            osc1.frequency.exponentialRampToValueAtTime(80, audioContext.currentTime + 0.05);
            osc1.frequency.exponentialRampToValueAtTime(45, audioContext.currentTime + 1.0);
            
            osc2.type = 'square';
            osc2.frequency.setValueAtTime(200, audioContext.currentTime);
            osc2.frequency.exponentialRampToValueAtTime(30, audioContext.currentTime + 0.8);
            
            // High-pitched scream for brightness
            osc3.type = 'square';
            osc3.frequency.setValueAtTime(1200, audioContext.currentTime);
            osc3.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.03);
            osc3.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.15);
            
            // Sharp blast at start, then long fade
            gain1.gain.setValueAtTime(0.6, audioContext.currentTime);
            gain1.gain.exponentialRampToValueAtTime(0.3, audioContext.currentTime + 0.05);
            gain1.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1.2);
            
            gain2.gain.setValueAtTime(0.4, audioContext.currentTime);
            gain2.gain.exponentialRampToValueAtTime(0.1, audioContext.currentTime + 0.1);
            gain2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1.0);
            
            // Bright scream - short but piercing
            gain3.gain.setValueAtTime(0.5, audioContext.currentTime);
            gain3.gain.exponentialRampToValueAtTime(0.2, audioContext.currentTime + 0.03);
            gain3.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            
            // Noise for turbulent jet texture
            noiseGain.gain.setValueAtTime(0.2, audioContext.currentTime);
            noiseGain.gain.exponentialRampToValueAtTime(0.05, audioContext.currentTime + 0.1);
            noiseGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.8);
            
            masterGain.gain.setValueAtTime(0.6, audioContext.currentTime); // Slightly louder
            
            osc1.start(audioContext.currentTime);
            osc2.start(audioContext.currentTime);
            osc3.start(audioContext.currentTime);
            noiseSource.start(audioContext.currentTime);
            
            osc1.stop(audioContext.currentTime + 1.2);
            osc2.stop(audioContext.currentTime + 1.0);
            osc3.stop(audioContext.currentTime + 0.2);
            noiseSource.stop(audioContext.currentTime + 0.8);
        }
        
        function createLaserSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Laser sound: high-pitched zap
            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.2);
            
            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.2);
        }
        
        function createUltraLaserSound() {
            // Ultra laser: more complex, powerful sound
            const osc1 = audioContext.createOscillator();
            const osc2 = audioContext.createOscillator();
            const osc3 = audioContext.createOscillator();
            
            const gain1 = audioContext.createGain();
            const gain2 = audioContext.createGain();
            const gain3 = audioContext.createGain();
            const masterGain = audioContext.createGain();
            
            osc1.connect(gain1);
            osc2.connect(gain2);
            osc3.connect(gain3);
            gain1.connect(masterGain);
            gain2.connect(masterGain);
            gain3.connect(masterGain);
            masterGain.connect(audioContext.destination);
            
            // Ultra laser: deeper, more powerful sound
            osc1.type = 'sawtooth';
            osc1.frequency.setValueAtTime(400, audioContext.currentTime);
            osc1.frequency.exponentialRampToValueAtTime(150, audioContext.currentTime + 0.3);
            
            osc2.type = 'square';
            osc2.frequency.setValueAtTime(1200, audioContext.currentTime);
            osc2.frequency.exponentialRampToValueAtTime(300, audioContext.currentTime + 0.25);
            
            osc3.type = 'triangle';
            osc3.frequency.setValueAtTime(800, audioContext.currentTime);
            osc3.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.35);
            
            gain1.gain.setValueAtTime(0.4, audioContext.currentTime);
            gain1.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
            
            gain2.gain.setValueAtTime(0.3, audioContext.currentTime);
            gain2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            
            gain3.gain.setValueAtTime(0.35, audioContext.currentTime);
            gain3.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.45);
            
            masterGain.gain.setValueAtTime(0.6, audioContext.currentTime);
            
            osc1.start(audioContext.currentTime);
            osc2.start(audioContext.currentTime);
            osc3.start(audioContext.currentTime);
            
            osc1.stop(audioContext.currentTime + 0.4);
            osc2.stop(audioContext.currentTime + 0.3);
            osc3.stop(audioContext.currentTime + 0.45);
        }
        
        function createExplosionSound() {
            // Create complex explosion sound with multiple layers
            const osc1 = audioContext.createOscillator();
            const osc2 = audioContext.createOscillator();
            const osc3 = audioContext.createOscillator();
            const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.5, audioContext.sampleRate);
            const noiseSource = audioContext.createBufferSource();
            
            // Create white noise for explosion texture
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < noiseBuffer.length; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            noiseSource.buffer = noiseBuffer;
            
            const gain1 = audioContext.createGain();
            const gain2 = audioContext.createGain();
            const gain3 = audioContext.createGain();
            const noiseGain = audioContext.createGain();
            const masterGain = audioContext.createGain();
            
            // Connect all sources
            osc1.connect(gain1);
            osc2.connect(gain2);
            osc3.connect(gain3);
            noiseSource.connect(noiseGain);
            gain1.connect(masterGain);
            gain2.connect(masterGain);
            gain3.connect(masterGain);
            noiseGain.connect(masterGain);
            masterGain.connect(audioContext.destination);
            
            // Explosion: sharp crack, mid boom, deep rumble
            osc1.type = 'square';  // Sharp crack
            osc1.frequency.setValueAtTime(800, audioContext.currentTime);
            osc1.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.1);
            
            osc2.type = 'sawtooth';  // Mid-range boom
            osc2.frequency.setValueAtTime(200, audioContext.currentTime);
            osc2.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.3);
            
            osc3.type = 'triangle';  // Deep rumble
            osc3.frequency.setValueAtTime(80, audioContext.currentTime);
            osc3.frequency.exponentialRampToValueAtTime(20, audioContext.currentTime + 0.6);
            
            // Sharp attack, exponential decay
            gain1.gain.setValueAtTime(0.8, audioContext.currentTime);
            gain1.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
            
            gain2.gain.setValueAtTime(0.6, audioContext.currentTime);
            gain2.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
            
            gain3.gain.setValueAtTime(0.4, audioContext.currentTime);
            gain3.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);
            
            // Noise burst for texture
            noiseGain.gain.setValueAtTime(0.3, audioContext.currentTime);
            noiseGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
            
            masterGain.gain.setValueAtTime(0.4, audioContext.currentTime);
            
            osc1.start(audioContext.currentTime);
            osc2.start(audioContext.currentTime);
            osc3.start(audioContext.currentTime);
            noiseSource.start(audioContext.currentTime);
            
            osc1.stop(audioContext.currentTime + 0.15);
            osc2.stop(audioContext.currentTime + 0.4);
            osc3.stop(audioContext.currentTime + 0.8);
            noiseSource.stop(audioContext.currentTime + 0.2);
        }
        
        // Dynamic game mechanics based on remaining words
        function calculateSpaceshipChaseSpeed() {
            const remainingWords = floatingTexts.filter(word => !word.isDestroyed).length;
            const baseSpeed = 4.8; // Current chase speed
            const desperationMultiplier = (12 - remainingWords) / 12 * 1.5;
            const dynamicSpeed = baseSpeed * (1 + desperationMultiplier);
            
            console.log(`Spaceship chase speed - Words: ${remainingWords}, Speed: ${dynamicSpeed.toFixed(1)}`);
            return dynamicSpeed; // 4.8 → 12.0
        }
        
        // HomingProjectile class for Ultra-Nachschuss
        class HomingProjectile {
            constructor(startX, startY, target, speed, turnRate) {
                this.x = startX;
                this.y = startY;
                this.target = target;
                this.speed = speed;
                this.turnRate = turnRate || 0.04; // How quickly it can turn toward target
                this.lifespan = 1500; // 1.5 seconds max lifetime
                this.age = 0;
                
                // Calculate initial velocity direction toward target
                const targetRect = target.element.getBoundingClientRect();
                const targetX = targetRect.left + targetRect.width / 2;
                const targetY = targetRect.top + targetRect.height / 2;
                
                const deltaX = targetX - startX;
                const deltaY = targetY - startY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                this.vx = (deltaX / distance) * speed;
                this.vy = (deltaY / distance) * speed;
                
                // Create DOM element
                this.element = this.createElement();
                document.querySelector('.container').appendChild(this.element);
                
                // NEUE ZEILE: Markiere das Zielwort visuell.
                if (this.target) this.target.element.classList.add('targeted');
            }
            
            createElement() {
                const projectile = document.createElement('div');
                projectile.className = 'laser ultra-laser';
                projectile.style.left = this.x + 'px';
                projectile.style.top = this.y + 'px';
                projectile.style.width = '18px';
                projectile.style.height = '18px';
                projectile.style.background = 'radial-gradient(circle, #aa44ff 0%, #6600aa 50%, #440088 100%)';
                projectile.style.border = '3px solid #ffffff';
                projectile.style.boxShadow = `
                    0 0 20px #aa44ff,
                    0 0 40px #aa44ff,
                    0 0 60px rgba(170, 68, 255, 0.8),
                    inset 0 0 8px rgba(255, 255, 255, 0.6)`;
                projectile.style.animation = 'ultraProjectilePulse 0.15s ease-in-out infinite alternate';
                return projectile;
            }
            
            update(deltaTime) {
                this.age += deltaTime;

                // Lebensdauer oder Ziel verloren -> zerstören
                if (this.age >= this.lifespan || !this.target || this.target.isDestroyed) {
                    this.destroy();
                    return false;
                }

                const targetRect = this.target.element.getBoundingClientRect();
                // Wichtig: Die Position des Ziels muss relativ zur Spielfläche (nicht zum Fenster) sein.
                const targetX = this.target.x + this.target.width / 2;
                const targetY = this.target.y + this.target.height / 2;

                // 1. Berechne Vektor zum Ziel
                const dirX = targetX - this.x;
                const dirY = targetY - this.y;
                const distance = Math.sqrt(dirX * dirX + dirY * dirY);

                // Kollision prüfen
                if (distance < 25) {
                    this.hitTarget();
                    return false;
                }

                // 2. Normalisiere Richtungsvektor
                const normDirX = dirX / distance;
                const normDirY = dirY / distance;

                // 3. Berechne "Lenk"-Kraft und passe Geschwindigkeit an
                this.vx += (normDirX * this.speed - this.vx) * this.turnRate;
                this.vy += (normDirY * this.speed - this.vy) * this.turnRate;

                // 4. Normalisiere die Geschwindigkeit, um konstanten Speed zu halten
                const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                this.vx = (this.vx / currentSpeed) * this.speed;
                this.vy = (this.vy / currentSpeed) * this.speed;

                // 5. Aktualisiere Position basierend auf Zeit (korrekte Umrechnung in Sekunden)
                this.x += this.vx * (deltaTime / 1000);
                this.y += this.vy * (deltaTime / 1000);

                // Die Position des DOM-Elements setzen
                this.element.style.left = this.x + 'px';
                this.element.style.top = this.y + 'px';
                
                return true; // Projektil ist noch aktiv
            }
            
            checkCollision() {
                if (!this.target || this.target.isDestroyed) return false;
                
                const targetRect = this.target.element.getBoundingClientRect();
                const targetCenterX = targetRect.left + targetRect.width / 2;
                const targetCenterY = targetRect.top + targetRect.height / 2;
                
                const distance = Math.sqrt(
                    Math.pow(this.x - targetCenterX, 2) + 
                    Math.pow(this.y - targetCenterY, 2)
                );
                
                return distance <= 25; // Collision radius
            }
            
            hitTarget() {
                console.log('Homing projectile hit target!');
                
                // Use spaceship controller's explode logic
                if (spaceshipController) {
                    spaceshipController.explodeWord(this.target);
                }
                
                this.destroy();
            }
            
            destroy() {
                if (this.element && this.element.parentNode) {
                    this.element.parentNode.removeChild(this.element);
                }
                
                // NEU: Entferne die visuelle Markierung vom Zielwort.
                if (this.target && this.target.element) {
                    this.target.element.classList.remove('targeted');
                }

                // Remove from active projectiles array
                const index = activeProjectiles.indexOf(this);
                if (index > -1) {
                    activeProjectiles.splice(index, 1);
                }
            }
        }
        
        function calculateBoosterFrequency() {
            const remainingWords = floatingTexts.filter(word => !word.isDestroyed).length;
            const baseFrequency = 0.4; // 40% chance currently
            const desperationFactor = (12 - remainingWords) / 12;
            const dynamicFrequency = Math.min(0.9, baseFrequency + desperationFactor * 0.5);
            
            return dynamicFrequency; // 40% → 90%
        }
        
        function calculateTargetingTime() {
            const remainingWords = floatingTexts.filter(word => !word.isDestroyed).length;
            const maxWords = 12;
            const minTime = 300; // 0.3 seconds minimum (faster than current)
            const maxTime = 1000; // 1.0 seconds maximum (current)
            
            // Calculate targeting time: more words = longer time, fewer words = shorter time
            const wordRatio = remainingWords / maxWords;
            const targetingTime = minTime + (maxTime - minTime) * wordRatio;
            
            return targetingTime; // 1000ms → 300ms
        }
        
        function calculateSpaceshipAggressiveness() {
            const remainingWords = floatingTexts.filter(word => !word.isDestroyed).length;
            const desperationFactor = (12 - remainingWords) / 12;
            
            return {
                chaseThreshold: Math.max(0.1, 0.4 - desperationFactor * 0.25), // 40% → 15% chase chance
                directionChangeSpeed: 1 + desperationFactor * 2, // 1x → 3x faster direction changes
                huntMode: remainingWords <= 4 // Aggressive hunt mode when ≤4 words
            };
        }
        
        function calculateDynamicFriction() {
            const remainingWords = floatingTexts.filter(word => !word.isDestroyed).length;
            const baseFriction = 0.995;
            const desperationFactor = (12 - remainingWords) / 12;
            const dynamicFriction = baseFriction - (desperationFactor * 0.008);
            
            return Math.max(dynamicFriction, 0.970); // Minimum friction threshold
        }
        
        function calculateDynamicRotationDamping() {
            const remainingWords = floatingTexts.filter(word => !word.isDestroyed).length;
            const baseDamping = 0.998;
            const desperationFactor = (12 - remainingWords) / 12;
            return baseDamping - (desperationFactor * 0.003); // Stronger damping when desperate
        }
        
        function calculateAttackInterval() {
            const remainingWords = floatingTexts.filter(word => !word.isDestroyed).length;
            if (remainingWords >= 9) return 10000;      // 10s
            if (remainingWords >= 6) return 9000;       // 9s  
            if (remainingWords >= 3) return 8000;       // 8s
            return 7000;                                // 7s (final phase)
        }
        
        function getSpaceshipAggressionLevel() {
            const remainingWords = floatingTexts.filter(word => !word.isDestroyed).length;
            const desperationFactor = (12 - remainingWords) / 12;
            return 1 + desperationFactor * 2; // 1x → 3x aggression
        }
        
        function updateEmergencyState() {
            const remainingWords = floatingTexts.filter(word => !word.isDestroyed).length;
            let emergencyOverlay = document.getElementById('emergency-overlay');
            
            if (remainingWords <= 3) {
                // Create emergency overlay if it doesn't exist
                if (!emergencyOverlay) {
                    emergencyOverlay = document.createElement('div');
                    emergencyOverlay.id = 'emergency-overlay';
                    emergencyOverlay.className = 'emergency-overlay';
                    emergencyOverlay.innerHTML = '<div class="emergency-border"></div>';
                    document.body.appendChild(emergencyOverlay);
                }
                
                // Activate emergency state
                emergencyOverlay.classList.add('active');
            } else {
                // Deactivate emergency state
                if (emergencyOverlay) {
                    emergencyOverlay.classList.remove('active');
                }
            }
        }
        
        function showInfoOverlay() {
            const overlay = document.createElement('div');
            overlay.className = 'info-overlay';
            overlay.innerHTML = `
                <div class="info-box">
                    <h1>WORD DEFENDER<br><span style="font-size: 0.6em; color: #ff4444;">vs. THE PSYCHO WORD HUNTER</span></h1>
                    <p>Ein Raumschiff jagt die schwebenden Wörter!</p>
                    <p><span class="highlight">Erste Angriffe beginnen nach 20 Sekunden</span> - dann alle 10 Sekunden.</p>
                    <p><span class="highlight">Rote Radar-Pings</span> warnen vor dem Angriff.</p>
                    <p>Das Radar und das Aufschalten <span class="highlight">passieren schnell</span> - sei bereit!</p>
                    <p>Klicke auf Wörter um sie zu bewegen und vor dem Schiff zu retten!</p>
                    <p>Überlebe so lange wie möglich! 🚀</p>
                    <input type="text" class="player-name-input" id="player-name" placeholder="Dein Name..." maxlength="20">
                    <div class="error-message" id="name-error">Bitte gib einen Namen ein!</div>
                    <button class="start-button" onclick="validateAndStartGame()">START GAME</button>
                </div>
            `;
            document.body.appendChild(overlay);
            
            // Load last used name
            const lastPlayer = localStorage.getItem('wordDefenderLastPlayer');
            if (lastPlayer) {
                document.getElementById('player-name').value = lastPlayer;
            }
            
            // Focus on input
            document.getElementById('player-name').focus();
            
            // Allow Enter key to start
            document.getElementById('player-name').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    validateAndStartGame();
                }
            });
        }
        
        function validateAndStartGame() {
            const nameInput = document.getElementById('player-name');
            const errorDiv = document.getElementById('name-error');
            const playerName = nameInput.value.trim();
            
            if (!playerName) {
                errorDiv.classList.add('show');
                nameInput.focus();
                return;
            }
            
            // Hide error and save name
            errorDiv.classList.remove('show');
            localStorage.setItem('wordDefenderLastPlayer', playerName);
            
            // Store current player name globally
            window.currentPlayerName = playerName;
            
            startGame();
        }
        
        // Highscore localStorage functions
        function loadHighscores() {
            const saved = localStorage.getItem('wordDefenderHighscores');
            return saved ? JSON.parse(saved) : [];
        }
        
        function saveHighscore(playerName, survivalTime, finalScore) {
            const highscores = loadHighscores();
            const newScore = {
                name: playerName,
                survivalTime: survivalTime,
                score: finalScore || 0, // Ensure score is always a number
                date: new Date().toISOString(),
                wordsDestroyed: 12 - floatingTexts.filter(word => !word.isDestroyed).length
            };
            
            highscores.push(newScore);
            
            // Ensure all existing scores have score property
            highscores.forEach(score => {
                if (typeof score.score === 'undefined') {
                    score.score = 0;
                }
            });
            
            // Sort by score first, then by survival time (both highest first)
            highscores.sort((a, b) => {
                if (b.score !== a.score) {
                    return b.score - a.score; // Higher score first
                }
                return b.survivalTime - a.survivalTime; // If score tied, longer time first
            });
            
            // Keep only top 10
            const topScores = highscores.slice(0, 10);
            
            localStorage.setItem('wordDefenderHighscores', JSON.stringify(topScores));
            
            return newScore;
        }
        
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }
        
        function showHighscoreTable(currentScoreData = null) {
            const highscores = loadHighscores();
            
            const tableHTML = `
                <div class="highscore-table">
                    <h2>🏆 HIGHSCORES</h2>
                    <ol class="highscore-list">
                        ${highscores.length > 0 
                            ? highscores.map((score, index) => `
                                <li class="highscore-entry ${currentScoreData && score === currentScoreData ? 'current' : ''}">
                                    <span class="highscore-rank">#${index + 1}</span>
                                    <span class="highscore-name">${score.name}</span>
                                    <span class="highscore-score">${score.score || 0}pts</span>
                                    <span class="highscore-time">${formatTime(score.survivalTime)}</span>
                                </li>
                            `).join('')
                            : '<li class="highscore-entry"><span style="text-align: center; width: 100%;">Noch keine Highscores</span></li>'
                        }
                    </ol>
                </div>
            `;
            
            return tableHTML;
        }
        
        function calculateScore() {
            let points;
            switch(consecutiveSuccessfulDefenses) {
                case 0: points = 100; break;
                case 1: points = 250; break;
                case 2: points = 500; break;
                default: points = 500; break; // Stay at 500 for subsequent defenses
            }
            return points;
        }
        
        function awardPoints() {
            const points = calculateScore();
            currentScore += points;
            consecutiveSuccessfulDefenses++;
            defendedWordsCounter++;
            
            // After 4th successful defense, reduce attack interval
            if (consecutiveSuccessfulDefenses === 4) {
                attackInterval = 8000; // Reduce from 10s to 8s
                console.log('Attack interval reduced to 8 seconds!');
            }
            
            // Beacon deployment logic
            beaconDeploymentCounter++;
            if (beaconDeploymentCounter === nextBeaconAt) {
                deployBeacon();
                
                // Set next beacon deployment
                if (nextBeaconAt === 4) {
                    nextBeaconAt = 6; // Next at 6th defense (4 + 2)
                } else {
                    nextBeaconAt += 2; // Every 2nd defense after that
                }
                
                console.log(`Beacon deployed! Next beacon at defense ${nextBeaconAt}`);
            }
            
            console.log(`Awarded ${points} points. Total: ${currentScore}. Consecutive defenses: ${consecutiveSuccessfulDefenses}. Total defended: ${defendedWordsCounter}. Beacon counter: ${beaconDeploymentCounter}`);
        }
        
        function resetScoreStreak() {
            consecutiveSuccessfulDefenses = 0;
            defendedWordsCounter = 0;
            
            // Reset pulsar system
            resetPulsar();
            
            // Reset beacon deployment counter but keep existing beacons
            beaconDeploymentCounter = 0;
            nextBeaconAt = 4;
            
            console.log('Score streak, defended counter, and beacon deployment counter reset to 0');
        }
        
        async function startGame() {
            const overlay = document.querySelector('.info-overlay');
            if (overlay) {
                overlay.remove();
            }
            
            // Zuerst alles zurücksetzen und initialisieren.
            shieldCount = 3;
            lastShieldTime = 0; // Wichtig für den ersten Cooldown-Timer
            protectedWords.clear();
            currentScore = 0;
            consecutiveSuccessfulDefenses = 0;
            attackInterval = 10000;
            hasFirstAttackHappened = false;
            defendedWordsCounter = 0;
            resetPulsar();
            beaconDeploymentCounter = 0;
            nextBeaconAt = 4;
            spaceBeacons.forEach(beacon => beacon.destroy());
            spaceBeacons = [];
            stopMineSpawning();
            
            // Reset second hunter
            secondSpaceshipController = null;
            
            // Warten, bis alle Wörter geladen und die Objekte erstellt sind.
            await initializeGame();
            
            // Erst NACH der Initialisierung das Spiel als gestartet markieren.
            gameStarted = true;
            gameStartTime = Date.now();
            
            // UI erstellen und aktualisieren.
            createGameUI();
            updateGameUI();
            startMineSpawning(); // Minen-Spawn erst jetzt starten.

            // Audio-Kontext fortsetzen, falls nötig.
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }
        
        function checkForGameEnd() {
            // Diese Prüfung läuft nur, wenn das Spiel aktiv ist und kein Overlay angezeigt wird.
            if (gameStarted && !document.querySelector('.info-overlay')) {
                const remainingWords = floatingTexts.filter(word => !word.isDestroyed).length;
                if (remainingWords === 0) {
                    console.log("Zentrale Prüfung: Alle Wörter zerstört! Spiel endet.");
                    
                    // Spiel anhalten und Endsequenz einleiten
                    gameStarted = false; // Stoppt die Logik in der animate-Schleife
                    showRestartButton(); // Zeigt den Highscore-Bildschirm an
                }
            }
        }

        function checkForSecondHunter() {
            // Nur einmal ausführen, wenn der zweite Jäger noch nicht existiert.
            if (!secondSpaceshipController) {
                const remainingWords = floatingTexts.filter(word => !word.isDestroyed).length;
                
                if (remainingWords <= 3) {
                    console.log('3 ODER WENIGER WORTE VERBLEIBEND! EIN ZWEITER JÄGER ERSCHEINT!');
                    secondSpaceshipController = new SpaceshipController();
                }
            }
        }

        function createGameUI() {
            const gameUI = document.createElement('div');
            gameUI.className = 'game-ui';
            gameUI.id = 'game-ui';
            gameUI.innerHTML = `
                <div class="ui-element words-remaining">
                    Wörter: <span id="words-count">12</span>
                </div>
                <div class="ui-element survival-time">
                    Zeit: <span id="survival-timer">00:00</span>
                </div>
                <div class="ui-element current-score">
                    Score: <span id="current-score">0</span>
                </div>
                <div class="ui-element defended-counter">
                    Verteidigt: <span id="defended-count">0</span>
                </div>
                <div class="ui-element spaceship-aggression">
                    Schiff: <span id="aggression-level" class="aggression-level calm">RUHIG</span>
                </div>
                <div class="ui-element" style="color: #ff88aa;">
                    Schusstypen: <span id="shot-chances" style="font-size: 14px;">🟢35% 🟡23% 🔴17% ⚡25%</span>
                </div>
                <div class="ui-element shield-system">
                    <div class="shield-counter">
                        🛡️ x<span id="shield-count">3</span>
                    </div>
                    <div class="shield-cooldown">
                        <div class="cooldown-bar" id="cooldown-bar"></div>
                        <span class="cooldown-text" id="cooldown-text"></span>
                    </div>
                    <div class="shield-hint">[SPACE] für Schild</div>
                </div>
            `;
            document.body.appendChild(gameUI);
        }

        function updateGameUI() {
            if (!gameStarted) return;
            
            const wordsCount = document.getElementById('words-count');
            const survivalTimer = document.getElementById('survival-timer');
            const currentScoreElement = document.getElementById('current-score');
            const defendedCountElement = document.getElementById('defended-count');
            
            if (wordsCount) {
                const remainingWords = floatingTexts.filter(word => !word.isDestroyed).length;
                wordsCount.textContent = remainingWords;
            }
            
            if (survivalTimer) {
                const elapsedTime = Math.floor((Date.now() - gameStartTime) / 1000);
                const minutes = Math.floor(elapsedTime / 60).toString().padStart(2, '0');
                const seconds = (elapsedTime % 60).toString().padStart(2, '0');
                survivalTimer.textContent = `${minutes}:${seconds}`;
            }
            
            if (currentScoreElement) {
                currentScoreElement.textContent = currentScore;
            }
            
            if (defendedCountElement) {
                defendedCountElement.textContent = defendedWordsCounter;
            }
            
            // Update spaceship aggression level
            const aggressionElement = document.getElementById('aggression-level');
            if (aggressionElement) {
                const remainingWords = floatingTexts.filter(word => !word.isDestroyed).length;
                const aggressiveness = calculateSpaceshipAggressiveness();
                
                aggressionElement.className = 'aggression-level';
                
                // Check if spaceship is in forced aggression mode
                const isInForcedMode = spaceshipController && spaceshipController.isInForcedAggressionMode;
                
                if (isInForcedMode) {
                    aggressionElement.textContent = 'ZWANGS-JAGD!';
                    aggressionElement.classList.add('hunting');
                } else if (remainingWords <= 2) {
                    aggressionElement.textContent = 'JAGD!';
                    aggressionElement.classList.add('hunting');
                } else if (remainingWords <= 4) {
                    aggressionElement.textContent = 'AGGRESSIV';
                    aggressionElement.classList.add('aggressive');
                } else if (remainingWords <= 7) {
                    aggressionElement.textContent = 'ALARMIERT';
                    aggressionElement.classList.add('alert');
                } else {
                    aggressionElement.textContent = 'RUHIG';
                    aggressionElement.classList.add('calm');
                }
            }
            
            // Update shot type chances display
            const shotChancesElement = document.getElementById('shot-chances');
            if (shotChancesElement) {
                const remainingWords = floatingTexts.filter(word => !word.isDestroyed).length;
                const isEarlyGame = remainingWords >= 7;
                
                if (isEarlyGame) {
                    shotChancesElement.textContent = '🟢35% 🟡23% 🔴17% ⚡25%';
                } else {
                    shotChancesElement.textContent = '🟢20% 🟡28% 🔴27% ⚡25%';
                }
            }
            
            // Update shield system
            updateShieldUI();
            
            // Update emergency state
            updateEmergencyState();
            
            // Update every second
            setTimeout(updateGameUI, 1000);
        }
        
        function updateShieldCooldown() {
            if (shieldCount < maxShields) {
                const now = Date.now();
                if (now - lastShieldTime >= shieldCooldown) {
                    shieldCount++;
                    lastShieldTime = now;
                }
            }
        }
        
        function updateShieldUI() {
            const shieldCountElement = document.getElementById('shield-count');
            const cooldownBar = document.getElementById('cooldown-bar');
            const cooldownText = document.getElementById('cooldown-text');
            
            if (shieldCountElement) {
                shieldCountElement.textContent = shieldCount;
            }
            
            if (cooldownBar && cooldownText) {
                if (shieldCount < maxShields) {
                    const now = Date.now();
                    const timeSinceLastShield = now - lastShieldTime;
                    const progress = Math.min(timeSinceLastShield / shieldCooldown, 1);
                    const timeRemaining = Math.max(0, Math.ceil((shieldCooldown - timeSinceLastShield) / 1000));
                    
                    cooldownBar.style.setProperty('--progress', `${progress * 100}%`);
                    cooldownText.textContent = timeRemaining > 0 ? `${timeRemaining}s` : '';
                } else {
                    cooldownBar.style.setProperty('--progress', '100%');
                    cooldownText.textContent = '';
                }
            }
            
            updateShieldCooldown();
        }
        
        function activateShield(word) {
            console.log('Attempting to shield word:', word.element.textContent, 'already shielded:', word.isShielded);
            
            if (!protectedWords.has(word) && !word.isShielded) {
                protectedWords.add(word);
                word.isShielded = true;
                word.element.classList.add('shielded-word');
                
                console.log('Shield activated successfully on:', word.element.textContent);
                
                // Shield sound effect
                try {
                    createShieldSound();
                } catch (e) {
                    console.log('Audio not available:', e);
                }
                
                // Remove shield after being hit or after 10 seconds
                setTimeout(() => {
                    console.log('Shield timeout for:', word.element.textContent);
                    removeShield(word);
                }, 10000);
                
                return true;
            }
            console.log('Shield activation failed - word already protected');
            return false; // Word already shielded
        }
        
        function removeShield(word) {
            if (word && protectedWords.has(word)) {
                console.log('Removing shield from:', word.element.textContent);
                protectedWords.delete(word);
                word.isShielded = false;
                word.element.classList.remove('shielded-word');
            }
        }
        
        function createShieldSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Shield activation sound: rising tone
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.3);
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.3);
        }
        
        function createShieldDeflectionEffect(target) {
            const rect = target.element.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            // Create multiple spark particles
            for (let i = 0; i < 8; i++) {
                const spark = document.createElement('div');
                spark.className = 'shield-spark';
                spark.style.position = 'fixed';
                spark.style.left = centerX + 'px';
                spark.style.top = centerY + 'px';
                spark.style.width = '4px';
                spark.style.height = '4px';
                spark.style.backgroundColor = '#44ffaa';
                spark.style.borderRadius = '50%';
                spark.style.pointerEvents = 'none';
                spark.style.zIndex = '2000';
                
                document.body.appendChild(spark);
                
                // Random direction for spark
                const angle = (i / 8) * Math.PI * 2;
                const distance = 30 + Math.random() * 20;
                const deltaX = Math.cos(angle) * distance;
                const deltaY = Math.sin(angle) * distance;
                
                // Animate spark
                spark.animate([
                    { transform: 'translate(0, 0) scale(1)', opacity: 1 },
                    { transform: `translate(${deltaX}px, ${deltaY}px) scale(0)`, opacity: 0 }
                ], {
                    duration: 500,
                    easing: 'ease-out'
                }).onfinish = () => {
                    spark.remove();
                };
            }
        }
        
        function createShieldDeflectionSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Shield deflection sound: metallic clang
            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(1200, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(300, audioContext.currentTime + 0.1);
            
            gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.2);
        }
        
        function showRestartButton() {
            // Calculate survival time
            const survivalTime = Math.floor((Date.now() - gameStartTime) / 1000);
            
            // Save highscore with final score
            const currentScoreData = saveHighscore(window.currentPlayerName, survivalTime, currentScore);
            
            // Create game over overlay with highscore table
            const overlay = document.createElement('div');
            overlay.className = 'info-overlay';
            
            const isFirstGame = loadHighscores().length === 1 && loadHighscores()[0] === currentScoreData;
            const congratsText = isFirstGame 
                ? "Dein erster Highscore!" 
                : currentScoreData === loadHighscores()[0] 
                    ? "🏆 NEUER REKORD!" 
                    : "Gut gespielt!";
            
            overlay.innerHTML = `
                <div class="info-box">
                    <h1>GAME OVER</h1>
                    <p style="color: #ffaa44; font-size: 20px; font-weight: 600;">${congratsText}</p>
                    <p>Du hast <span class="highlight">${formatTime(survivalTime)}</span> überlebt!</p>
                    <p><span class="highlight">${currentScore}</span> Punkte erreicht!</p>
                    <p><span class="highlight">${12 - floatingTexts.filter(word => !word.isDestroyed).length}</span> Wörter zerstört.</p>
                    ${showHighscoreTable(currentScoreData)}
                    <button class="start-button" onclick="restartGame()" style="margin-top: 20px;">NEUES SPIEL</button>
                </div>
            `;
            document.body.appendChild(overlay);
        }
        
        function restartGame() {
            const overlay = document.querySelector('.info-overlay');
            if (overlay) {
                overlay.remove();
            }

            if (restartButton) {
                restartButton.remove();
                restartButton = null;
            }

            const gameUI = document.getElementById('game-ui');
            if (gameUI) {
                gameUI.remove();
            }

            const emergencyOverlay = document.getElementById('emergency-overlay');
            if (emergencyOverlay) {
                emergencyOverlay.remove();
            }

            if (spaceshipShootTimer) {
                clearTimeout(spaceshipShootTimer);
                clearInterval(spaceshipShootTimer);
            }

            if (radarPingInterval) {
                clearInterval(radarPingInterval);
                radarPingInterval = null;
            }

            // KORREKTUR: Entferne BEIDE Raumschiffe und ihre Controller
            if (spaceshipController && spaceshipController.spaceship && spaceshipController.spaceship.parentNode) {
                spaceshipController.spaceship.remove();
            }
            if (secondSpaceshipController && secondSpaceshipController.spaceship && secondSpaceshipController.spaceship.parentNode) {
                secondSpaceshipController.spaceship.remove();
            }
            spaceshipController = null;
            secondSpaceshipController = null; // WICHTIG: Setzt den zweiten Jäger zurück

            floatingTexts.forEach(word => {
                if (word.element && word.element.parentNode) {
                    word.element.parentNode.removeChild(word.element);
                }
            });
            floatingTexts = [];

            activeProjectiles.forEach(projectile => {
                projectile.destroy();
            });
            activeProjectiles = [];

            // Spielstatus vollständig zurücksetzen
            gameStarted = false;
            gameStartTime = 0;
            shieldCount = 3;
            lastShieldTime = 0;
            protectedWords.clear();
            currentScore = 0;
            consecutiveSuccessfulDefenses = 0;
            attackInterval = 10000;
            hasFirstAttackHappened = false;
            defendedWordsCounter = 0;
            resetPulsar();
            
            // Info-Overlay für den Neustart anzeigen
            showInfoOverlay();
        }
        
        async function initializeGame() {
            await loadWords();
            
            const container = document.querySelector('.container');
            const goldenSizes = calculateGoldenRatioSizes();
            
            // Create word elements dynamically from JSON data
            wordsData.forEach((wordData, index) => {
                const element = document.createElement('span');
                element.className = 'hello';
                element.textContent = wordData.text;
                element.style.fontWeight = wordData.fontWeight;
                element.style.color = wordData.color;
                element.style.opacity = wordData.opacity;
                element.title = wordData.language;
                
                container.appendChild(element);
                floatingTexts.push(new FloatingText(element, index + 1, goldenSizes[index]));
            });
            
            // Initialize spaceship
            spaceshipController = new SpaceshipController();
        }
        
        class SpaceshipController {
            constructor() {
                this.container = document.querySelector('.container');
                this.spaceship = null;
                this.x = containerWidth / 2;
                this.y = containerHeight / 2;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.targetVx = this.vx;
                this.targetVy = this.vy;
                this.changeDirectionTimer = 0;
                this.rotation = 0;
                this.targetRotation = 0;
                this.isChasing = false;
                this.chaseTarget = null;
                this.shootingRadius = Math.min(containerWidth, containerHeight) / 2.5; // War / 5 -> Verdoppelt
                this.radarRadius = Math.min(containerWidth, containerHeight) / 1.5; // War / 2 -> Deutlich vergrößert für längere Vorwarnzeit
                this.MAX_FIRING_ANGLE = 30; // ±30° Schusswinkel vor dem Schiff
                this.COLLISION_RADIUS = 25; // Kollisions-Radius für Projektil-Treffer
                this.targetingWord = null;
                this.targetingTimer = null;
                this.radarPing = null;
                this.chaseAttempts = 0; // Track chase attempts for current target
                this.maxChaseAttempts = 1; // Will be set randomly (1-2)
                this.aggressionModeTimer = 0; // Timer for checking aggression mode switches
                this.isInForcedAggressionMode = false; // Track if ship is in forced aggression mode
                this.forcedAggressionDuration = 0; // How long to stay in forced aggression mode
                this.createSpaceship();
                this.startShootingTimer();
            }
            
            createSpaceship() {
                this.spaceship = document.createElement('div');
                this.spaceship.className = 'spaceship';
                this.spaceship.style.left = this.x + 'px';
                this.spaceship.style.top = this.y + 'px';
                this.spaceship.innerHTML = `
                    <svg viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <linearGradient id="spaceshipGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                <stop offset="0%" style="stop-color:#silver;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#darkgray;stop-opacity:1" />
                            </linearGradient>
                        </defs>
                        <!-- Main body -->
                        <ellipse cx="25" cy="31.25" rx="10" ry="15" fill="url(#spaceshipGradient)" stroke="#666" stroke-width="1"/>
                        <!-- Cockpit -->
                        <ellipse cx="25" cy="18.75" rx="5" ry="7.5" fill="#4488ff" opacity="0.7"/>
                        <!-- Wings -->
                        <polygon points="15,37.5 10,43.75 15,40" fill="url(#spaceshipGradient)" stroke="#666"/>
                        <polygon points="35,37.5 40,43.75 35,40" fill="url(#spaceshipGradient)" stroke="#666"/>
                        <!-- Engine glow -->
                        <ellipse cx="25" cy="46.25" rx="3.75" ry="2.5" fill="#ff4444" opacity="0.8"/>
                        <ellipse cx="25" cy="47.5" rx="2.5" ry="1.25" fill="#ffff44" opacity="0.9"/>
                    </svg>
                `;
                this.container.appendChild(this.spaceship);
            }

            showBooster() {
                const booster = document.createElement('div');
                booster.className = 'booster-flame';
                this.spaceship.appendChild(booster);
                
                // Play booster sound
                try {
                    createBoosterSound();
                } catch (e) {
                    console.log('Audio not available:', e);
                }
                
                setTimeout(() => {
                    if (booster.parentNode) {
                        booster.remove();
                    }
                }, 500);
            }
            
            update() {
                if (this.isChasing && this.chaseTarget && !this.chaseTarget.isDestroyed) {
                    // Chase mode - move toward target
                    const targetRect = this.chaseTarget.element.getBoundingClientRect();
                    const targetX = targetRect.left + targetRect.width / 2;
                    const targetY = targetRect.top + targetRect.height / 2;
                    
                    const deltaX = targetX - (this.x + 25);
                    const deltaY = targetY - (this.y + 25);
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    // Check if target is now in radar range for targeting
                    if (distance <= this.radarRadius) {
                        this.isChasing = false;
                        this.startTargeting(this.chaseTarget);
                        this.chaseTarget = null;
                        return;
                    }
                    
                    // Move toward target with dynamic boosted speed
                    const chaseSpeed = calculateSpaceshipChaseSpeed();
                    this.vx = (deltaX / distance) * chaseSpeed;
                    this.vy = (deltaY / distance) * chaseSpeed;
                    
                    // Rotate toward target
                    this.targetRotation = Math.atan2(deltaY, deltaX) * 180 / Math.PI + 90;
                    
                } else {
                    // Normal patrol mode with dynamic aggressiveness
                    const remainingWords = floatingTexts.filter(word => !word.isDestroyed).length;
                    
                    // Check for forced aggression mode when >=7 targets (30% chance every 3 seconds)
                    if (remainingWords >= 7 && !this.isInForcedAggressionMode) {
                        this.aggressionModeTimer++;
                        if (this.aggressionModeTimer >= 180) { // 3 seconds at 60fps
                            this.aggressionModeTimer = 0;
                            if (Math.random() < 0.3) { // 30% chance
                                this.isInForcedAggressionMode = true;
                                this.forcedAggressionDuration = 300 + Math.random() * 300; // 5-10 seconds
                                console.log('Ship entered forced aggression mode for', (this.forcedAggressionDuration / 60).toFixed(1), 'seconds!');
                                this.showBooster(); // Visual indication of mode switch
                            }
                        }
                    }
                    
                    // Handle forced aggression mode duration
                    if (this.isInForcedAggressionMode) {
                        this.forcedAggressionDuration--;
                        if (this.forcedAggressionDuration <= 0) {
                            this.isInForcedAggressionMode = false;
                            console.log('Ship exited forced aggression mode');
                        }
                    }
                    
                    const aggressiveness = calculateSpaceshipAggressiveness();
                    const changeSpeedMultiplier = aggressiveness.directionChangeSpeed;
                    
                    // Apply forced aggression mode effects
                    const effectiveAggressiveness = this.isInForcedAggressionMode ? {
                        ...aggressiveness,
                        huntMode: true,
                        directionChangeSpeed: Math.max(aggressiveness.directionChangeSpeed, 2.0),
                        chaseThreshold: Math.min(aggressiveness.chaseThreshold, 0.2)
                    } : aggressiveness;
                    
                    this.changeDirectionTimer++;
                    const baseChangeInterval = 180;
                    const dynamicChangeInterval = baseChangeInterval / effectiveAggressiveness.directionChangeSpeed;
                    
                    if (this.changeDirectionTimer > dynamicChangeInterval + Math.random() * 120) {
                        const speedMultiplier = effectiveAggressiveness.huntMode ? 1.5 : 1.0;
                        this.targetVx = (Math.random() - 0.5) * 3 * speedMultiplier;
                        this.targetVy = (Math.random() - 0.5) * 3 * speedMultiplier;
                        this.targetRotation = Math.atan2(this.targetVy, this.targetVx) * 180 / Math.PI + 90;
                        this.changeDirectionTimer = 0;
                    }
                    
                    // Smooth transition to target velocity
                    this.vx += (this.targetVx - this.vx) * 0.02;
                    this.vy += (this.targetVy - this.vy) * 0.02;
                }
                
                // Check if currently targeting word is still in range
                if (this.targetingWord && !this.targetingWord.isDestroyed) {
                    const rect = this.targetingWord.element.getBoundingClientRect();
                    const wordX = rect.left + rect.width / 2;
                    const wordY = rect.top + rect.height / 2;
                    const distance = Math.sqrt(
                        Math.pow(wordX - (this.x + 25), 2) + 
                        Math.pow(wordY - (this.y + 25), 2)
                    );
                    
                    if (distance > this.radarRadius) {
                        // Target escaped radar range completely, cancel targeting
                        this.cancelTargeting();
                        
                        console.log('Word escaped radar range - repositioning');
                        
                        // Check if we should chase or switch target
                        const remainingWords = floatingTexts.filter(word => !word.isDestroyed);
                        const aggressiveness = calculateSpaceshipAggressiveness();
                        
                        // Apply forced aggression mode effects
                        const effectiveAggressiveness = this.isInForcedAggressionMode ? {
                            ...aggressiveness,
                            huntMode: true,
                            chaseThreshold: Math.min(aggressiveness.chaseThreshold, 0.2)
                        } : aggressiveness;
                        
                        if (remainingWords.length < 3) {
                            // Few words left: Higher chase chance (60% instead of 40%)
                            if (Math.random() < 0.6) {
                                this.chaseAttempts++;
                                if (this.chaseAttempts <= this.maxChaseAttempts) {
                                    // Continue chasing this target
                                    setTimeout(() => {
                                        this.startChasing(this.targetingWord);
                                    }, 500);
                                } else {
                                    // Switch to random target after max attempts
                                    this.chaseAttempts = 0;
                                    this.maxChaseAttempts = Math.floor(Math.random() * 2) + 1; // 1-2 attempts
                                    setTimeout(() => {
                                        this.shootAtRandomWord();
                                    }, 500);
                                }
                            } else {
                                // Switch to random target immediately (40% chance)
                                this.chaseAttempts = 0;
                                this.maxChaseAttempts = Math.floor(Math.random() * 2) + 1; // 1-2 attempts
                                setTimeout(() => {
                                    this.shootAtRandomWord();
                                }, 500);
                            }
                        } else {
                            // Many words left: Dynamic chase chance based on effective aggressiveness
                            const baseChaseChance = effectiveAggressiveness.huntMode ? 0.3 : 0.15;
                            // Increase chase chance further if in forced aggression mode
                            const chaseChance = this.isInForcedAggressionMode ? Math.min(baseChaseChance * 1.5, 0.6) : baseChaseChance;
                            if (Math.random() < chaseChance) {
                                this.chaseAttempts++;
                                if (this.chaseAttempts <= this.maxChaseAttempts) {
                                    // Continue chasing this target
                                    setTimeout(() => {
                                        this.startChasing(this.targetingWord);
                                    }, 500);
                                } else {
                                    // Switch to random target after max attempts
                                    this.chaseAttempts = 0;
                                    this.maxChaseAttempts = Math.floor(Math.random() * 2) + 1; // 1-2 attempts
                                    setTimeout(() => {
                                        this.shootAtRandomWord();
                                    }, 500);
                                }
                            } else {
                                // Switch to random target immediately
                                this.chaseAttempts = 0;
                                this.maxChaseAttempts = Math.floor(Math.random() * 2) + 1; // 1-2 attempts
                                setTimeout(() => {
                                    this.shootAtRandomWord();
                                }, 500);
                            }
                        }                } else {
                    // Target still in radar range but outside shooting range: continue targeting
                    // Re-schedule targeting attempt after a short delay
                    this.targetingTimer = setTimeout(() => {
                        this.executeShot();
                    }, 500);
                }                }
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // Bounce off edges with margin
                const margin = 60;
                if (this.x < margin) {
                    this.x = margin;
                    this.vx = Math.abs(this.vx);
                    this.targetVx = Math.abs(this.targetVx);
                } else if (this.x > containerWidth - margin) {
                    this.x = containerWidth - margin;
                    this.vx = -Math.abs(this.vx);
                    this.targetVx = -Math.abs(this.targetVx);
                }
                
                if (this.y < margin) {
                    this.y = margin;
                    this.vy = Math.abs(this.vy);
                    this.targetVy = Math.abs(this.targetVy);
                } else if (this.y > containerHeight - margin) {
                    this.y = containerHeight - margin;
                    this.vy = -Math.abs(this.vy);
                    this.targetVy = -Math.abs(this.targetVy);
                }
                
                // Smooth rotation
                let rotationDiff = this.targetRotation - this.rotation;
                if (rotationDiff > 180) rotationDiff -= 360;
                if (rotationDiff < -180) rotationDiff += 360;
                this.rotation += rotationDiff * 0.1;
                
                // Update spaceship position and rotation
                this.spaceship.style.left = this.x + 'px';
                this.spaceship.style.top = this.y + 'px';
                this.spaceship.style.transform = `rotate(${this.rotation}deg)`;
            }
            
            startShootingTimer() {
                // First attack after 20 seconds
                const initialDelay = hasFirstAttackHappened ? calculateAttackInterval() : 20000;
                
                spaceshipShootTimer = setTimeout(() => {
                    hasFirstAttackHappened = true;
                    if (!this.targetingWord) { // Only shoot if not already targeting
                        this.shootAtRandomWord();
                    }
                    
                    // Continue with dynamic intervals
                    const scheduleNextAttack = () => {
                        spaceshipShootTimer = setTimeout(() => {
                            if (!this.targetingWord) { // Only shoot if not already targeting
                                this.shootAtRandomWord();
                            }
                            scheduleNextAttack(); // Schedule next attack with current interval
                        }, calculateAttackInterval());
                    };
                    
                    scheduleNextAttack();
                }, initialDelay);
            }
            
            shootAtRandomWord() {
                // Get all available words and categorize them by distance
                const availableWords = floatingTexts.filter(word => !word.isDestroyed);
                if (availableWords.length === 0) return;
                
                const wordsInRadar = [];
                const wordsOutsideRadar = [];
                
                availableWords.forEach(word => {
                    const rect = word.element.getBoundingClientRect();
                    const wordX = rect.left + rect.width / 2;
                    const wordY = rect.top + rect.height / 2;
                    const distance = Math.sqrt(
                        Math.pow(wordX - (this.x + 25), 2) + 
                        Math.pow(wordY - (this.y + 25), 2)
                    );
                    
                    if (distance <= this.radarRadius) {
                        wordsInRadar.push(word);
                    } else {
                        wordsOutsideRadar.push(word);
                    }
                });
                
                let target;
                
                // Priority: Choose words outside radar range (requires chasing)
                if (wordsOutsideRadar.length > 0) {
                    target = wordsOutsideRadar[Math.floor(Math.random() * wordsOutsideRadar.length)];
                    console.log('Targeting word outside radar range - will chase');
                    
                    // Target is outside radar range: chase first
                    this.resetChaseAttempts();
                    this.startChasing(target);
                    
                } else {
                    // Fallback: Choose from words in radar range (immediate targeting)
                    target = wordsInRadar[Math.floor(Math.random() * wordsInRadar.length)];
                    console.log('All words in radar range - targeting immediately');
                    
                    // Target in radar range: can target immediately
                    this.resetChaseAttempts();
                    
                    // Random radar boost for unpredictable acceleration (40% chance)
                    if (Math.random() < 0.4) {
                        console.log('Random radar boost triggered! Aggressive approach!');
                        this.showBooster();
                    }
                    
                    this.startTargeting(target);
                }
            }
            
            resetChaseAttempts() {
                this.chaseAttempts = 0;
                this.maxChaseAttempts = Math.floor(Math.random() * 2) + 1; // 1-2 attempts
            }
            
            calculateAngleToTarget(target) {
                const targetRect = target.element.getBoundingClientRect();
                const targetX = targetRect.left + targetRect.width / 2;
                const targetY = targetRect.top + targetRect.height / 2;
                
                const deltaX = targetX - (this.x + 25);
                const deltaY = targetY - (this.y + 25);
                return Math.atan2(deltaY, deltaX) * 180 / Math.PI + 90;
            }
            
            checkProjectileCollision(projectileX, projectileY, target) {
                if (!target || target.isDestroyed) return false;
                
                const targetRect = target.element.getBoundingClientRect();
                const targetCenterX = targetRect.left + targetRect.width / 2;
                const targetCenterY = targetRect.top + targetRect.height / 2;
                
                const distance = Math.sqrt(
                    Math.pow(projectileX - targetCenterX, 2) + 
                    Math.pow(projectileY - targetCenterY, 2)
                );
                
                return distance <= this.COLLISION_RADIUS;
            }
            
            startTargeting(target) {
                if (this.targetingWord) return; // Already targeting
                
                this.targetingWord = target;
                target.element.classList.add('targeted'); // Add red glow
                this.showRadarPing(target);
                
                // Aim at target
                const targetRect = target.element.getBoundingClientRect();
                const targetX = targetRect.left + targetRect.width / 2;
                const targetY = targetRect.top + targetRect.height / 2;
                
                const deltaX = targetX - (this.x + 25);
                const deltaY = targetY - (this.y + 25);
                this.targetRotation = Math.atan2(deltaY, deltaX) * 180 / Math.PI + 90;
                
                // Check if this might be an ultra shot and adjust targeting time
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const isLongRange = distance > this.shootingRadius;
                
                // Wait time based on remaining words (dynamic targeting speed)
                // Ultra shots (long range) take 2x longer to target
                let targetingTime = calculateTargetingTime();
                if (isLongRange) {
                    targetingTime *= 2;
                    console.log('Long range target detected - extended targeting time:', targetingTime);
                }
                
                this.targetingTimer = setTimeout(() => {
                    // Dynamic booster effect frequency
                    const boosterFrequency = calculateBoosterFrequency();
                    if (Math.random() < boosterFrequency) {
                        this.showBooster();
                    }
                    this.executeShot();
                }, targetingTime);
            }
            
            showRadarPing(target) {
                const targetRect = target.element.getBoundingClientRect();
                const targetX = targetRect.left + targetRect.width / 2;
                const targetY = targetRect.top + targetRect.height / 2;
                
                this.radarPing = document.createElement('div');
                this.radarPing.className = 'radar-ping';
                this.radarPing.style.left = targetX + 'px';
                this.radarPing.style.top = targetY + 'px';
                this.radarPing.style.width = '30px';
                this.radarPing.style.height = '30px';
                
                this.container.appendChild(this.radarPing);
                
                // Update ping position as target moves
                this.updatePingPosition();
                
                // Start random interval radar pings (1-2 seconds)
                this.startRadarPingInterval();
            }
            
            startRadarPingInterval() {
                if (radarPingInterval) {
                    clearInterval(radarPingInterval);
                }
                
                const scheduleNextPing = () => {
                    const randomInterval = 500 + Math.random() * 500; // 0.5-1 seconds
                    radarPingInterval = setTimeout(() => {
                        if (this.targetingWord && !this.targetingWord.isDestroyed) {
                            this.createRadarPing();
                            scheduleNextPing(); // Schedule next ping
                        }
                    }, randomInterval);
                };
                
                scheduleNextPing();
            }
            
            createRadarPing() {
                if (!this.targetingWord || this.targetingWord.isDestroyed) return;
                
                const targetRect = this.targetingWord.element.getBoundingClientRect();
                const targetX = targetRect.left + targetRect.width / 2;
                const targetY = targetRect.top + targetRect.height / 2;
                
                const ping = document.createElement('div');
                ping.className = 'radar-ping';
                ping.style.left = targetX + 'px';
                ping.style.top = targetY + 'px';
                ping.style.width = '30px';
                ping.style.height = '30px';
                
                this.container.appendChild(ping);
                
                // Remove ping after animation completes
                setTimeout(() => {
                    if (ping.parentNode) {
                        ping.remove();
                    }
                }, 500);
            }
            
            updatePingPosition() {
                if (this.radarPing && this.targetingWord && !this.targetingWord.isDestroyed) {
                    const targetRect = this.targetingWord.element.getBoundingClientRect();
                    const targetX = targetRect.left + targetRect.width / 2;
                    const targetY = targetRect.top + targetRect.height / 2;
                    
                    this.radarPing.style.left = targetX + 'px';
                    this.radarPing.style.top = targetY + 'px';
                    
                    setTimeout(() => this.updatePingPosition(), 50);
                }
            }
            
            cancelTargeting() {
                if (this.targetingTimer) {
                    clearTimeout(this.targetingTimer);
                    this.targetingTimer = null;
                }
                
                if (radarPingInterval) {
                    clearTimeout(radarPingInterval);
                    radarPingInterval = null;
                }
                
                if (this.radarPing) {
                    this.radarPing.remove();
                    this.radarPing = null;
                }
                
                if (this.targetingWord) {
                    this.targetingWord.element.classList.remove('targeted'); // Remove red glow
                    this.targetingWord = null;
                }
            }
            
            executeShot() {
                if (!this.targetingWord) return;
                
                // Determine shot type first
                const shotType = this.calculateShotType();
                
                const rect = this.targetingWord.element.getBoundingClientRect();
                const wordX = rect.left + rect.width / 2;
                const wordY = rect.top + rect.height / 2;
                const distance = Math.sqrt(
                    Math.pow(wordX - (this.x + 25), 2) + 
                    Math.pow(wordY - (this.y + 25), 2)
                );
                
                // Check if target is in range (normal shots use shootingRadius, ultra shots use extended range)
                const effectiveRange = shotType.type === 'ultra' ? 
                    this.shootingRadius * shotType.rangeMultiplier : 
                    this.shootingRadius;
                
                if (distance <= effectiveRange) {
                    // Berechne Winkel zum Ziel
                    const targetAngle = this.calculateAngleToTarget(this.targetingWord);
                    const shipFacing = this.rotation;
                    
                    // Berechne Winkeldifferenz
                    let angleDiff = targetAngle - shipFacing;
                    while (angleDiff > 180) angleDiff -= 360;
                    while (angleDiff < -180) angleDiff += 360;
                    
                    // Ultra shots have wider firing angle (±45° instead of ±30°)
                    const maxFiringAngle = shotType.type === 'ultra' ? 45 : this.MAX_FIRING_ANGLE;
                    
                    if (Math.abs(angleDiff) <= maxFiringAngle) {
                        // Ziel im Schusswinkel: feuern!
                        console.log(`Firing ${shotType.name}! Angle diff: ${angleDiff.toFixed(1)}° (within ±${maxFiringAngle}°), Range: ${distance.toFixed(0)}/${effectiveRange.toFixed(0)}`);
                        this.fireLaser(this.targetingWord);
                        this.cancelTargeting();
                    } else {
                        // Ziel außerhalb Schusswinkel: repositionieren
                        console.log(`Target outside firing angle: ${angleDiff.toFixed(1)}° (max ±${maxFiringAngle}°) - repositioning`);
                        this.targetRotation = targetAngle;
                        // Retry nach kurzer Zeit
                        this.targetingTimer = setTimeout(() => this.executeShot(), 200);
                    }
                } else if (distance > this.radarRadius) {
                    // Target escaped radar range completely, cancel targeting
                    this.cancelTargeting();
                    
                    console.log('Word escaped radar range during executeShot - repositioning');
                    
                    // Try to target another word
                    const chaseProb = calculateDynamicChaseProb();
                    if (Math.random() < chaseProb) {
                        setTimeout(() => {
                            if (!this.targetingWord) { // Only shoot if not already targeting
                                this.shootAtRandomWord();
                            }
                        }, 500 + Math.random() * 1000);
                    } else {
                        setTimeout(() => {
                            if (!this.targetingWord) { // Only shoot if not already targeting
                                this.shootAtRandomWord();
                            }
                        }, 1500 + Math.random() * 2000);
                    }
                } else {
                    // Target still in radar range but outside shooting range: continue targeting
                    // Wait a bit longer and try again
                    this.targetingTimer = setTimeout(() => this.executeShot(), 200);
                }
            }
            
            startChasing(target) {
                this.isChasing = true;
                this.chaseTarget = target;
                this.showBooster();
            }
            
            calculateShotType() {
                const remainingWords = floatingTexts.filter(word => !word.isDestroyed).length;
                const isEarlyGame = remainingWords >= 7;
                
                const random = Math.random() * 100;
                
                // Ultra shot now has 25% chance
                if (random < 25) {
                    return {
                        type: 'ultra',
                        name: 'Ultra-Nachschuss',
                        speedMultiplier: 1.25, // +25% base speed increase
                        chance: 25,
                        rangeMultiplier: 3.0,
                        color: '#aa44ff',
                        size: 18
                    };
                }
                
                // Adjust remaining percentages (75% total)
                if (isEarlyGame) {
                    // Early game: 35% normal, 23% yellow, 17% red (scaled to 75%)
                    if (random < 25 + 35) { // 25-60%
                        return {
                            type: 'normal',
                            name: 'Grün (Normal)',
                            speedMultiplier: 1.25, // +25% base speed increase
                            chance: 35,
                            rangeMultiplier: 3.0, // 3x range for all shots
                            color: '#44ff44',
                            size: 12
                        };
                    } else if (random < 25 + 35 + 23) { // 60-83%
                        return {
                            type: 'yellow',
                            name: 'Gelb (+15%)',
                            speedMultiplier: 1.44, // 1.15 * 1.25 = 1.44 (+44% total)
                            chance: 23,
                            rangeMultiplier: 3.0, // 3x range for all shots
                            color: '#ffff44',
                            size: 14
                        };
                    } else { // 83-100%
                        return {
                            type: 'red',
                            name: 'Rot (+30%)',
                            speedMultiplier: 1.63, // 1.30 * 1.25 = 1.63 (+63% total)
                            chance: 17,
                            rangeMultiplier: 3.0, // 3x range for all shots
                            color: '#ff4444',
                            size: 16
                        };
                    }
                } else {
                    // Late game: 20% normal, 28% yellow, 27% red (scaled to 75%)
                    if (random < 25 + 20) { // 25-45%
                        return {
                            type: 'normal',
                            name: 'Grün (Normal)',
                            speedMultiplier: 1.25, // +25% base speed increase
                            chance: 20,
                            rangeMultiplier: 3.0, // 3x range for all shots
                            color: '#44ff44',
                            size: 12
                        };
                    } else if (random < 25 + 20 + 28) { // 45-73%
                        return {
                            type: 'yellow',
                            name: 'Gelb (+15%)',
                            speedMultiplier: 1.44, // 1.15 * 1.25 = 1.44 (+44% total)
                            chance: 28,
                            rangeMultiplier: 3.0, // 3x range for all shots
                            color: '#ffff44',
                            size: 14
                        };
                    } else { // 73-100%
                        return {
                            type: 'red',
                            name: 'Rot (+30%)',
                            speedMultiplier: 1.63, // 1.30 * 1.25 = 1.63 (+63% total)
                            chance: 27,
                            rangeMultiplier: 3.0, // 3x range for all shots
                            color: '#ff4444',
                            size: 16
                        };
                    }
                }
            }
            
            applyProjectileStyles(projectile, shotType) {
                projectile.style.width = shotType.size + 'px';
                projectile.style.height = shotType.size + 'px';
                
                if (shotType.type === 'ultra') {
                    projectile.style.background = `radial-gradient(circle, ${shotType.color} 0%, #6600aa 50%, #440088 100%)`;
                    projectile.style.border = '3px solid #ffffff';
                    projectile.style.boxShadow = `
                        0 0 20px ${shotType.color},
                        0 0 40px ${shotType.color},
                        0 0 60px rgba(170, 68, 255, 0.8),
                        inset 0 0 8px rgba(255, 255, 255, 0.6)`;
                } else {
                    projectile.style.background = `radial-gradient(circle, ${shotType.color} 0%, #ff4400 50%, #ff0000 100%)`;
                    projectile.style.border = '2px solid #ffffff';
                    projectile.style.boxShadow = `
                        0 0 15px ${shotType.color},
                        0 0 30px ${shotType.color},
                        0 0 45px rgba(255, 68, 0, 0.8),
                        inset 0 0 6px rgba(255, 255, 255, 0.6)`;
                }
            }
            
            fireLaser(target) {
                const spaceshipX = this.x + 20; // Center of spaceship
                const spaceshipY = this.y + 20;
                
                const targetRect = target.element.getBoundingClientRect();
                const targetX = targetRect.left + targetRect.width / 2;
                const targetY = targetRect.top + targetRect.height / 2;
                
                // Determine shot type based on probability
                const shotType = this.calculateShotType();
                console.log(`Shot type selected: ${shotType.name} (${shotType.chance}% chance)`);
                
                // Play appropriate laser sound
                try {
                    if (shotType.type === 'ultra') {
                        createUltraLaserSound();
                    } else {
                        createLaserSound();
                    }
                } catch (e) {
                    console.log('Audio not available:', e);
                }
                
                // Handle ultra shots with homing projectiles
                if (shotType.type === 'ultra') {
                    const baseSpeed = 480 * 1.25; // Basis-Geschwindigkeit (600 p/s)
                    const homingProjectile = new HomingProjectile(
                        spaceshipX,
                        spaceshipY,
                        target,
                        baseSpeed, // Übergib die volle Geschwindigkeit (in Pixel pro Sekunde)
                        0.1 // Erhöhe die Wenderate für aggressivere Kurven
                    );
                    activeProjectiles.push(homingProjectile);
                    console.log('Homing projectile launched at', target.element.textContent);
                    return; // Wichtig: Beende die Funktion hier für Ultra-Schüsse
                }
                
                // Regular projectiles for non-ultra shots
                const projectile = document.createElement('div');
                projectile.className = 'laser';
                projectile.style.left = spaceshipX + 'px';
                projectile.style.top = spaceshipY + 'px';
                
                // Apply shot type specific styling
                if (shotType.type !== 'normal') {
                    this.applyProjectileStyles(projectile, shotType);
                }
                
                this.container.appendChild(projectile);
                
                // Calculate projectile trajectory with speed multiplier
                const deltaX = targetX - spaceshipX;
                const deltaY = targetY - spaceshipY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const baseSpeed = 480 * shotType.speedMultiplier; // Base projectile speed with +25% increase
                const duration = distance / baseSpeed;
                
                // Collision detection variables
                let collisionDetected = false;
                let collisionCheckInterval;
                const startTime = Date.now();
                
                // Start collision detection loop
                collisionCheckInterval = setInterval(() => {
                    if (collisionDetected || target.isDestroyed) {
                        clearInterval(collisionCheckInterval);
                        return;
                    }
                    
                    // Calculate current projectile position based on elapsed time
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / (duration * 1000), 1);
                    
                    const currentX = spaceshipX + (deltaX * progress);
                    const currentY = spaceshipY + (deltaY * progress);
                    
                    // Check collision
                    if (this.checkProjectileCollision(currentX, currentY, target)) {
                        collisionDetected = true;
                        clearInterval(collisionCheckInterval);
                        
                        // Stop projectile animation and explode at current position
                        projectile.style.left = currentX + 'px';
                        projectile.style.top = currentY + 'px';
                        
                        setTimeout(() => {
                            projectile.remove();
                            console.log('Projectile hit target!');
                            this.explodeWord(target);
                        }, 50);
                    }
                }, 16); // Check every ~60fps
                
                // Animate circular projectile with rotation effect
                const animation = projectile.animate([
                    { 
                        transform: 'translate(0, 0) rotate(0deg)', 
                        opacity: 1 
                    },
                    { 
                        transform: `translate(${deltaX}px, ${deltaY}px) rotate(720deg)`, 
                        opacity: 1 
                    }
                ], {
                    duration: duration * 1000,
                    easing: 'linear'
                });
                
                animation.onfinish = () => {
                    clearInterval(collisionCheckInterval);
                    if (!collisionDetected) {
                        projectile.remove();
                        console.log('Projectile missed target!');
                        
                        // Award points for successful defense - shot missed
                        awardPoints();
                        console.log('Shot missed - defense successful! Points awarded.');
                    }
                };
                
                // Add projectile trail effect
                this.createProjectileTrail(spaceshipX, spaceshipY, targetX, targetY, duration);
            }
            
            createProjectileTrail(startX, startY, endX, endY, duration) {
                const trail = document.createElement('div');
                trail.style.position = 'absolute';
                trail.style.left = startX + 'px';
                trail.style.top = startY + 'px';
                trail.style.width = '2px';
                trail.style.height = '2px';
                trail.style.background = 'rgba(255, 68, 0, 0.6)';
                trail.style.borderRadius = '50%';
                trail.style.pointerEvents = 'none';
                trail.style.zIndex = '998';
                trail.style.boxShadow = '0 0 8px rgba(255, 68, 0, 0.8)';
                
                this.container.appendChild(trail);
                
                // Animate trail following projectile path
                const deltaX = endX - startX;
                const deltaY = endY - startY;
                
                trail.animate([
                    { 
                        transform: 'translate(0, 0) scale(1)',
                        opacity: 0.8 
                    },
                    { 
                        transform: `translate(${deltaX}px, ${deltaY}px) scale(0.3)`,
                        opacity: 0 
                    }
                ], {
                    duration: duration * 1000 * 1.2, // Trail lasts slightly longer
                    easing: 'ease-out'
                }).onfinish = () => {
                    trail.remove();
                };
            }
            
            explodeWord(target) {
                console.log('Explosion attempt on word:', target.element.textContent, 'isShielded:', target.isShielded);
                
                // Check if target is shielded
                if (target.isShielded) {
                    console.log('Shield deflection successful!');
                    // Shield deflection effect
                    createShieldDeflectionEffect(target);
                    removeShield(target);
                    
                    // Award points for successful defense
                    awardPoints();
                    
                    // Play shield deflection sound
                    try {
                        createShieldDeflectionSound();
                    } catch (e) {
                        console.log('Audio not available:', e);
                    }
                    
                    return; // Don't destroy shielded word
                }
                
                console.log('Word exploded - no shield protection');
                
                // Reset score streak when word is destroyed
                resetScoreStreak();
                
                target.explode();
            }
        }
        
        async function loadWords() {
            try {
                const response = await fetch('words.json');
                const data = await response.json();
                wordsData = data.words;
                return wordsData;
            } catch (error) {
                console.error('Could not load words.json, using fallback data:', error);
                // Fallback data in case words.json can't be loaded
                wordsData = [
                    { text: "hello", language: "English", fontWeight: 800, color: "#FFB3BA", opacity: 0.9 },
                    { text: "hola", language: "Spanish", fontWeight: 300, color: "#BAFFC9", opacity: 0.8 },
                    { text: "bonjour", language: "French", fontWeight: 600, color: "#BAE1FF", opacity: 0.7 },
                    { text: "ciao", language: "Italian", fontWeight: 500, color: "#FFFFBA", opacity: 0.8 },
                    { text: "hallo", language: "German", fontWeight: 400, color: "#FFD1FF", opacity: 0.6 },
                    { text: "こんにちは", language: "Japanese", fontWeight: 700, color: "#FFDFBA", opacity: 0.5 },
                    { text: "olá", language: "Portuguese", fontWeight: 600, color: "#E1BAFF", opacity: 0.9 },
                    { text: "привет", language: "Russian", fontWeight: 400, color: "#BAFFE1", opacity: 0.7 },
                    { text: "merhaba", language: "Turkish", fontWeight: 800, color: "#FFC9BA", opacity: 0.9 },
                    { text: "안녕하세요", language: "Korean", fontWeight: 300, color: "#C9BAFF", opacity: 0.6 },
                    { text: "namaste", language: "Hindi", fontWeight: 500, color: "#BAFFD1", opacity: 0.8 },
                    { text: "shalom", language: "Hebrew", fontWeight: 700, color: "#FFE1BA", opacity: 0.8 }
                ];
                return wordsData;
            }
        }
        
        function calculateGoldenRatioSizes() {
            const baseFontSize = Math.min(containerWidth, containerHeight) / 15 * 2; // Double the scale
            const minFontSize = Math.max(48, baseFontSize / 6); // Minimum also doubled
            const goldenRatioSizes = [];
            
            // Create different scaling variations while maintaining golden ratio relationships
            const scaleVariations = [1.2, 0.8, 1.0, 1.3, 0.9, 1.1, 0.7, 1.4, 0.85, 1.15, 0.95, 1.25];
            
            let currentSize = baseFontSize;
            for (let i = 0; i < wordsData.length; i++) {
                const variation = scaleVariations[i % scaleVariations.length];
                const sizeWithVariation = Math.max(currentSize * variation, minFontSize);
                goldenRatioSizes.push(sizeWithVariation);
                currentSize /= PHI;
            }
            
            return goldenRatioSizes.sort(() => Math.random() - 0.5);
        }
        
        class FloatingText {
            constructor(element, index, fontSize) {
                this.element = element;
                this.index = index;
                this.fontSize = fontSize;
                this.initialFontSize = fontSize; // Store the initial font size
                this.isDestroyed = false;
                
                this.element.style.fontSize = this.fontSize + 'px';
                
                setTimeout(() => {
                    this.width = this.element.offsetWidth;
                    this.height = this.element.offsetHeight;
                    
                    this.x = containerWidth / 2 - this.width / 2 + (Math.random() - 0.5) * 100;
                    this.y = containerHeight / 2 - this.height / 2 + (Math.random() - 0.5) * 100;
                    
                    this.vx = (Math.random() - 0.5) * 3;
                    this.vy = (Math.random() - 0.5) * 3;
                    this.rotation = Math.random() * 360;
                    this.rotationSpeed = (Math.random() - 0.5) * 0.5;
                    this.baseRotationSpeed = (Math.random() - 0.5) * 0.3;
                    
                this.element.style.transform = `translate3d(${this.x}px, ${this.y}px, 0) rotate(${this.rotation}deg)`;                    this.element.style.zIndex = index;
                    
                    this.setupInteractionHandlers();
                }, 10);
            }
            
            setupInteractionHandlers() {
                this.element.addEventListener('click', (e) => {
                    // Get click position relative to word element
                    const rect = this.element.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    const clickY = e.clientY - rect.top;
                    
                    // Calculate center of word
                    const centerX = rect.width / 2;
                    const centerY = rect.height / 2;
                    
                    // Calculate distance from center (normalized to 0-1)
                    const deltaX = clickX - centerX;
                    const deltaY = clickY - centerY;
                    const distanceFromCenter = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const maxDistance = Math.sqrt(centerX * centerX + centerY * centerY);
                    const normalizedDistance = Math.min(distanceFromCenter / maxDistance, 1);
                    
                    let escapeAngle;
                    
                    if (normalizedDistance > 0.3) {
                        // Near edges: escape direction based on click position
                        escapeAngle = Math.atan2(deltaY, deltaX);
                    } else {
                        // Near center: random direction
                        escapeAngle = Math.random() * 2 * Math.PI;
                    }
                    
                    const baseForce = 14.375; // Fixed click force
                    
                    // Apply directional impulse
                    this.vx = Math.cos(escapeAngle) * baseForce;
                    this.vy = Math.sin(escapeAngle) * baseForce;
                    
                    // Add rotation based on escape direction
                    // Positive angle = counter-clockwise rotation
                    const rotationDirection = Math.sign(Math.sin(escapeAngle - Math.PI/4));
                    this.rotationSpeed = rotationDirection * (4 + Math.random() * 4);
                    
                    e.preventDefault();
                });
            }
            
            isNearEdge() {
                const margin = Math.min(containerWidth, containerHeight) * 0.15;
                return (this.x <= margin || 
                        this.x >= containerWidth - this.width - margin ||
                        this.y <= margin || 
                        this.y >= containerHeight - this.height - margin);
            }
            
            addRotationalImpulse() {
                this.rotationSpeed += (Math.random() - 0.5) * 8;
            }
            
            explode() {
                if (this.isDestroyed) return;
                this.isDestroyed = true;
                
                // Play explosion sound
                try {
                    createExplosionSound();
                } catch (e) {
                    console.log('Audio not available:', e);
                }
                
                const rect = this.element.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                // Create explosion particles
                const particleCount = 20;
                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'explosion-particle';
                    particle.style.left = centerX + 'px';
                    particle.style.top = centerY + 'px';
                    particle.style.background = this.element.style.color || '#ffff00';
                    
                    document.querySelector('.container').appendChild(particle);
                    
                    // Random explosion direction and speed
                    const angle = (i / particleCount) * 360 + Math.random() * 30;
                    const speed = 150 + Math.random() * 150;
                    const deltaX = Math.cos(angle * Math.PI / 180) * speed;
                    const deltaY = Math.sin(angle * Math.PI / 180) * speed;
                    
                    // Animate particle explosion
                    particle.animate([
                        { transform: 'translate(0, 0) scale(1)', opacity: 1 },
                        { transform: `translate(${deltaX}px, ${deltaY}px) scale(0.2)`, opacity: 0 }
                    ], {
                        duration: 1200 + Math.random() * 800,
                        easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
                    }).onfinish = () => {
                        particle.remove();
                    };
                }
                
                // Hide and remove the word element
                this.element.style.opacity = '0';
                setTimeout(() => {
                    if (this.element.parentNode) {
                        this.element.parentNode.removeChild(this.element);
                    }
                }, 100);
            }
            
            update() {
                if (this.isDestroyed || !this.width) return;
                
                // Simple physics - no center attraction, no orbital mechanics
                this.x += this.vx;
                this.y += this.vy;
                this.rotation += this.rotationSpeed + this.baseRotationSpeed;
                
                // Progressive friction - words naturally slow down
                const dynamicFriction = calculateDynamicFriction();
                const dynamicRotationDamping = calculateDynamicRotationDamping();
                
                this.vx *= dynamicFriction;
                this.vy *= dynamicFriction;
                this.rotationSpeed *= dynamicRotationDamping;
                
                // Auto-escape from UI overlap zone
                const UI_ZONE = { x: 0, y: 0, width: 350, height: 250 };
                const ESCAPE_THRESHOLD = 1.0; // Only push slow-moving words
                
                if (this.x < UI_ZONE.width && this.y < UI_ZONE.height) {
                    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                    if (speed < ESCAPE_THRESHOLD) {
                        // Apply gentle escape force away from UI
                        const escapeForce = 3.0;
                        const centerX = UI_ZONE.width / 2;
                        const centerY = UI_ZONE.height / 2;
                        
                        // Direction away from UI center
                        const deltaX = this.x - centerX;
                        const deltaY = this.y - centerY;
                        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                        
                        if (distance > 0) {
                            this.vx += (deltaX / distance) * escapeForce;
                            this.vy += (deltaY / distance) * escapeForce;
                        } else {
                            // If exactly in center, push down-right
                            this.vx += escapeForce;
                            this.vy += escapeForce;
                        }
                    }
                }
                
                // Edge bouncing with force loss
                let isColliding = false;
                const bounceMargin = 30;
                
                if (this.x <= bounceMargin) {
                    this.vx = Math.abs(this.vx) * 0.7; // Lose energy on bounce
                    this.x = bounceMargin + 1;
                    isColliding = true;
                } else if (this.x >= containerWidth - this.width - bounceMargin) {
                    this.vx = -Math.abs(this.vx) * 0.7;
                    this.x = containerWidth - this.width - bounceMargin - 1;
                    isColliding = true;
                }
                
                // NEUE OBERE KOLLISION mit der UI-Leiste
                if (this.y <= UI_BAR_HEIGHT) {
                    this.vy = Math.abs(this.vy) * 0.7; // Energieverlust beim Aufprall
                    this.y = UI_BAR_HEIGHT + 1; // Position direkt unter die Leiste setzen
                    isColliding = true;
                } else if (this.y >= containerHeight - this.height - bounceMargin) {
                    this.vy = -Math.abs(this.vy) * 0.7;
                    this.y = containerHeight - this.height - bounceMargin - 1;
                    isColliding = true;
                }
                
                if (isColliding) {
                    this.rotationSpeed += (Math.random() - 0.5) * 2; // Less spin on collision
                    this.element.classList.add('glowing');
                    setTimeout(() => {
                        this.element.classList.remove('glowing');
                    }, 400);
                }
                
                this.element.style.transform = `translate3d(${this.x}px, ${this.y}px, 0) rotate(${this.rotation}deg)`;
            }
            
            resize() {
                containerWidth = window.innerWidth;
                containerHeight = window.innerHeight;
                
                if (this.width && this.height) {
                    this.x = Math.min(this.x, containerWidth - this.width - 50);
                    this.y = Math.min(this.y, containerHeight - this.height - 50);
                }
                
                // Keep the initial font size unchanged during resize
                this.element.style.fontSize = this.initialFontSize + 'px';
                
                setTimeout(() => {
                    this.width = this.element.offsetWidth;
                    this.height = this.element.offsetHeight;
                }, 10);
            }
        }
        
        // Space Beacon Mine System
        class SpaceBeacon {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.detectionRadius = 100; // Warning radius
                this.blastRadius = 60; // Explosion radius
                this.isExploded = false;
                this.isTargeting = false;
                this.targetingWord = null;
                this.targetingTimer = null;
                this.radarPing = null;
                this.element = this.createElement();
                this.container = document.querySelector('.container');
                this.container.appendChild(this.element);
            }
            
            createElement() {
                const beacon = document.createElement('div');
                beacon.className = 'space-beacon';
                beacon.style.left = (this.x - 12) + 'px'; // Center the 24px beacon
                beacon.style.top = (this.y - 12) + 'px';
                return beacon;
            }
            
            update() {
                if (this.isExploded) return;
                
                // Check for nearby words to target
                this.checkForTargets();
            }
            
            checkForTargets() {
                if (this.isTargeting) return;
                
                for (let word of floatingTexts) {
                    if (word.isDestroyed || word.isShielded) continue;
                    
                    // Use getBoundingClientRect for accurate visual position (like Spaceship)
                    const rect = word.element.getBoundingClientRect();
                    const wordCenterX = rect.left + rect.width / 2;
                    const wordCenterY = rect.top + rect.height / 2;
                    const distance = Math.sqrt(
                        Math.pow(wordCenterX - this.x, 2) + 
                        Math.pow(wordCenterY - this.y, 2)
                    );
                    
                    // Debug output
                    if (distance <= this.detectionRadius + 20) { // Log when close
                        console.log('Space beacon checking word:', word.element.textContent, 'Distance:', Math.round(distance), 'Detection radius:', this.detectionRadius);
                    }
                    
                    if (distance <= this.detectionRadius) {
                        console.log('Space beacon starting targeting for:', word.element.textContent);
                        this.startTargeting(word);
                        break;
                    }
                }
            }
            
            startTargeting(word) {
                if (this.isTargeting) return;
                
                this.isTargeting = true;
                this.targetingWord = word;
                this.element.classList.add('targeting');
                
                // Create radar ping
                this.createRadarPing(word);
                
                // Set targeting timer
                const targetingTime = 500; // 0.5 seconds warning
                this.targetingTimer = setTimeout(() => {
                    console.log('Space beacon timer expired, executing explosion');
                    this.executeExplosion();
                }, targetingTime);
                
                console.log('Space beacon targeting word:', word.element.textContent, 'Timer set for', targetingTime + 'ms');
            }
            
            createRadarPing(word) {
                this.radarPing = document.createElement('div');
                this.radarPing.className = 'radar-ping';
                this.radarPing.style.left = (word.x + word.width/2 - 15) + 'px';
                this.radarPing.style.top = (word.y + word.height/2 - 15) + 'px';
                this.container.appendChild(this.radarPing);
            }
            
            executeExplosion() {
                console.log('Space beacon executeExplosion called');
                
                if (!this.targetingWord || this.targetingWord.isDestroyed) {
                    console.log('No valid targeting word, canceling');
                    this.cancelTargeting();
                    return;
                }
                
                // Check if word is still in blast range
                const wordCenterX = this.targetingWord.x + this.targetingWord.width / 2;
                const wordCenterY = this.targetingWord.y + this.targetingWord.height / 2;
                const distance = Math.sqrt(
                    Math.pow(wordCenterX - this.x, 2) + 
                    Math.pow(wordCenterY - this.y, 2)
                );
                
                console.log('Final distance check:', Math.round(distance), 'vs blast radius:', this.blastRadius);
                
                if (distance <= this.blastRadius) {
                    // Check if word is shielded
                    if (this.targetingWord.isShielded) {
                        console.log('Space beacon blocked by shield!');
                        this.targetingWord.isShielded = false;
                        this.targetingWord.element.classList.remove('shielded-word');
                        // Award points for successful shield defense
                        awardPoints();
                    } else {
                        // Destroy the word
                        console.log('Space beacon destroyed word:', this.targetingWord.element.textContent);
                        this.targetingWord.explode();
                    }
                } else {
                    // Word escaped, continue beacon operation
                    console.log('Word escaped space beacon - no points awarded');
                }
                
                this.explode();
            }
            
            cancelTargeting() {
                if (this.targetingTimer) {
                    clearTimeout(this.targetingTimer);
                    this.targetingTimer = null;
                }
                
                if (this.radarPing && this.radarPing.parentNode) {
                    this.radarPing.parentNode.removeChild(this.radarPing);
                }
                
                if (this.targetingWord) {
                    this.targetingWord.element.classList.remove('targeted');
                    this.targetingWord = null;
                }
                
                this.element.classList.remove('targeting');
                this.isTargeting = false;
            }
            
            explode() {
                if (this.isExploded) return;
                
                this.isExploded = true;
                this.cancelTargeting();
                
                console.log('Space beacon exploding at:', this.x, this.y);
                
                // Create explosion effect
                const explosion = document.createElement('div');
                explosion.className = 'beacon-explosion';
                explosion.style.left = this.x + 'px';
                explosion.style.top = this.y + 'px';
                this.container.appendChild(explosion);
                
                // Play beacon explosion sound
                try {
                    createMineExplosionSound();
                } catch (e) {
                    console.log('Audio not available:', e);
                }
                
                // Remove explosion effect after animation
                setTimeout(() => {
                    if (explosion.parentNode) {
                        explosion.parentNode.removeChild(explosion);
                    }
                }, 600);
                
                // Check for words in blast radius and destroy them
                floatingTexts.forEach(word => {
                    if (word.isDestroyed) return;
                    
                    const wordCenterX = word.x + word.width / 2;
                    const wordCenterY = word.y + word.height / 2;
                    const distance = Math.sqrt(
                        Math.pow(wordCenterX - this.x, 2) + 
                        Math.pow(wordCenterY - this.y, 2)
                    );
                    
                    if (distance <= this.blastRadius) {
                        if (word.isShielded) {
                            console.log('Word protected by shield from space beacon explosion');
                            word.isShielded = false;
                            word.element.classList.remove('shielded-word');
                            awardPoints();
                        } else {
                            console.log('Word destroyed by space beacon explosion:', word.element.textContent);
                            word.explode();
                        }
                    }
                });
                
                this.destroy();
            }
            
            destroy() {
                if (this.element && this.element.parentNode) {
                    this.element.parentNode.removeChild(this.element);
                }
                
                // Remove from spaceBeacons array
                const index = spaceBeacons.indexOf(this);
                if (index > -1) {
                    spaceBeacons.splice(index, 1);
                }
            }
        }
        
        function deployBeacon() {
            if (spaceBeacons.length >= maxBeacons) {
                // Remove oldest beacon
                const oldestBeacon = spaceBeacons.shift();
                oldestBeacon.destroy();
            }
            
            // Find a safe position away from words and UI
            let attempts = 0;
            let x, y;
            
            do {
                x = 400 + Math.random() * (containerWidth - 800); // Avoid UI and edges
                y = 100 + Math.random() * (containerHeight - 200);
                attempts++;
            } while (attempts < 10 && isPositionNearWords(x, y, 120));
            
            const beacon = new SpaceBeacon(x, y);
            spaceBeacons.push(beacon);
            
            console.log('Space beacon deployed at:', x, y, 'Total beacons:', spaceBeacons.length);
        }
        
        function isPositionNearWords(x, y, minDistance) {
            for (let word of floatingTexts) {
                if (word.isDestroyed) continue;
                
                const wordCenterX = word.x + word.width / 2;
                const wordCenterY = word.y + word.height / 2;
                const distance = Math.sqrt(
                    Math.pow(wordCenterX - x, 2) + 
                    Math.pow(wordCenterY - y, 2)
                );
                
                if (distance < minDistance) {
                    return true;
                }
            }
            return false;
        }
        
        function updateBeacons() {
            spaceBeacons.forEach(beacon => {
                beacon.update();
            });
        }
        
        function createExplosionSound() {
            // Create explosive sound effect
            const osc1 = audioContext.createOscillator();
            const osc2 = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            osc1.connect(gainNode);
            osc2.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Deep explosive rumble
            osc1.frequency.setValueAtTime(60, audioContext.currentTime);
            osc1.frequency.exponentialRampToValueAtTime(30, audioContext.currentTime + 0.3);
            
            // Sharp explosion crack
            osc2.frequency.setValueAtTime(800, audioContext.currentTime);
            osc2.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.2);
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.4);
            
            osc1.start(audioContext.currentTime);
            osc2.start(audioContext.currentTime);
            osc1.stop(audioContext.currentTime + 0.4);
            osc2.stop(audioContext.currentTime + 0.4);
        }
        
        // Floating Mine Threat System
        class FloatingMine {
            constructor() {
                this.container = document.querySelector('.container');
                this.findSafePosition();
                this.vx = (Math.random() - 0.5) * 1.5; // Slow floating movement
                this.vy = (Math.random() - 0.5) * 1.5;
                this.isDestroyed = false;
                this.isTargeting = false;
                this.targetingWord = null;
                this.targetingTimer = null;
                this.radarPing = null;
                this.element = this.createElement();
                this.container.appendChild(this.element);
                
                // Auto-explode after lifespan
                setTimeout(() => {
                    if (!this.isDestroyed) {
                        console.log('Floating mine auto-exploding after lifespan');
                        this.explode();
                    }
                }, mineLifespan);
                
                console.log('Floating mine spawned at:', this.x, this.y);
            }
            
            findSafePosition() {
                let attempts = 0;
                do {
                    this.x = 200 + Math.random() * (containerWidth - 400);
                    this.y = 150 + Math.random() * (containerHeight - 300);
                    attempts++;
                } while (attempts < 20 && (isPositionNearWords(this.x, this.y, 100) || this.isInUIZone()));
            }
            
            isInUIZone() {
                return this.x < 350 && this.y < 250;
            }
            
            createElement() {
                const mine = document.createElement('div');
                mine.className = 'floating-mine';
                mine.style.left = this.x + 'px';
                mine.style.top = this.y + 'px';
                
                // No click handler - mines are threats, not collectibles
                
                return mine;
            }
            
            update() {
                if (this.isDestroyed) return;
                
                // Floating physics similar to words but slower
                this.x += this.vx;
                this.y += this.vy;
                
                // Very light friction
                this.vx *= 0.995;
                this.vy *= 0.995;
                
                // Edge bouncing
                const margin = 50;
                if (this.x <= margin || this.x >= containerWidth - margin) {
                    this.vx *= -0.8;
                    this.x = Math.max(margin, Math.min(containerWidth - margin, this.x));
                }
                if (this.y <= margin || this.y >= containerHeight - margin) {
                    this.vy *= -0.8;
                    this.y = Math.max(margin, Math.min(containerHeight - margin, this.y));
                }
                
                this.element.style.left = this.x + 'px';
                this.element.style.top = this.y + 'px';
                
                // Check for nearby words to target
                this.checkForTargets();
            }
            
            checkForTargets() {
                if (this.isTargeting) return;
                
                const DETECTION_RADIUS = 100;
                
                // Debug: Log mine position every few frames
                if (Math.random() < 0.01) { // 1% chance to log
                    console.log('Floating mine at:', Math.round(this.x), Math.round(this.y), 'checking for targets...');
                }
                
                for (let word of floatingTexts) {
                    if (word.isDestroyed || word.isShielded) continue;
                    
                    // Use getBoundingClientRect for accurate visual position (like Spaceship)
                    const rect = word.element.getBoundingClientRect();
                    const wordX = rect.left + rect.width / 2;
                    const wordY = rect.top + rect.height / 2;
                    
                    const distance = Math.sqrt(
                        Math.pow(wordX - this.x, 2) + 
                        Math.pow(wordY - this.y, 2)
                    );
                    
                    // Debug: Log close encounters
                    if (distance <= DETECTION_RADIUS + 40) { // Log when getting close
                        console.log('Floating mine distance to', word.element.textContent + ':', Math.round(distance), '(detection:', DETECTION_RADIUS + ')');
                    }
                    
                    if (distance <= DETECTION_RADIUS) {
                        console.log('Floating mine starting targeting for:', word.element.textContent, 'at distance:', Math.round(distance));
                        this.startTargeting(word);
                        break;
                    }
                }
            }
            
            startTargeting(word) {
                if (this.isTargeting) return;
                
                this.isTargeting = true;
                this.targetingWord = word;
                this.element.classList.add('targeted');
                
                // Create radar ping
                this.createRadarPing(word);
                
                // Set targeting timer (similar to spaceship but shorter)
                const targetingTime = 500; // 0.5 seconds warning
                this.targetingTimer = setTimeout(() => {
                    this.executeDestruction();
                }, targetingTime);
                
                console.log('Floating mine targeting word:', word.element.textContent);
            }
            
            createRadarPing(word) {
                this.radarPing = document.createElement('div');
                this.radarPing.className = 'radar-ping';
                this.radarPing.style.left = (word.x + word.width/2 - 15) + 'px';
                this.radarPing.style.top = (word.y + word.height/2 - 15) + 'px';
                this.container.appendChild(this.radarPing);
            }
            
            executeDestruction() {
                if (!this.targetingWord || this.targetingWord.isDestroyed) {
                    this.cancelTargeting();
                    return;
                }
                
                // Check if word is still in range using getBoundingClientRect
                const rect = this.targetingWord.element.getBoundingClientRect();
                const wordX = rect.left + rect.width / 2;
                const wordY = rect.top + rect.height / 2;
                
                const distance = Math.sqrt(
                    Math.pow(wordX - this.x, 2) + 
                    Math.pow(wordY - this.y, 2)
                );
                
                if (distance <= 80) {
                    // Check if word is shielded
                    if (this.targetingWord.isShielded) {
                        console.log('Floating mine blocked by shield!');
                        this.targetingWord.isShielded = false;
                        this.targetingWord.element.classList.remove('shielded-word');
                        // Award points for successful shield defense
                        awardPoints();
                        // Mine explodes even when blocked by shield
                        this.explode();
                    } else {
                        // Explode and destroy word
                        console.log('Floating mine exploding near word:', this.targetingWord.element.textContent);
                        this.explode();
                    }
                } else {
                    // Word escaped, continue mine operation
                    console.log('Word escaped floating mine - no points awarded');
                    this.destroy(); // Mine just disappears if no target
                }
                
                this.cancelTargeting();
            }
            
            cancelTargeting() {
                if (this.targetingTimer) {
                    clearTimeout(this.targetingTimer);
                    this.targetingTimer = null;
                }
                
                if (this.radarPing && this.radarPing.parentNode) {
                    this.radarPing.parentNode.removeChild(this.radarPing);
                }
                
                if (this.targetingWord) {
                    this.targetingWord.element.classList.remove('targeted');
                    this.targetingWord = null;
                }
                
                this.element.classList.remove('targeted');
                this.isTargeting = false;
            }
            
            explode() {
                if (this.isDestroyed) return;
                
                console.log('Floating mine exploding at:', this.x, this.y);
                
                // Create explosion effect
                const explosion = document.createElement('div');
                explosion.className = 'beacon-explosion';
                explosion.style.left = this.x + 'px';
                explosion.style.top = this.y + 'px';
                explosion.style.background = 'radial-gradient(circle, #88ff88 0%, #44ff44 30%, #22aa22 60%, transparent 100%)';
                this.container.appendChild(explosion);
                
                // Play mine explosion sound
                try {
                    createMineExplosionSound();
                } catch (e) {
                    console.log('Audio not available:', e);
                }
                
                // Remove explosion effect after animation
                setTimeout(() => {
                    if (explosion.parentNode) {
                        explosion.parentNode.removeChild(explosion);
                    }
                }, 600);
                
                // Check for words in blast radius and destroy them
                const BLAST_RADIUS = 80;
                floatingTexts.forEach(word => {
                    if (word.isDestroyed) return;
                    
                    // Use getBoundingClientRect for accurate visual position
                    const rect = word.element.getBoundingClientRect();
                    const wordX = rect.left + rect.width / 2;
                    const wordY = rect.top + rect.height / 2;
                    
                    const distance = Math.sqrt(
                        Math.pow(wordX - this.x, 2) + 
                        Math.pow(wordY - this.y, 2)
                    );
                    
                    if (distance <= BLAST_RADIUS) {
                        if (word.isShielded) {
                            console.log('Word protected by shield from floating mine explosion');
                            word.isShielded = false;
                            word.element.classList.remove('shielded-word');
                            awardPoints();
                        } else {
                            console.log('Word destroyed by floating mine explosion:', word.element.textContent);
                            word.explode();
                        }
                    }
                });
                
                this.destroy();
            }
            
            destroy() {
                if (this.isDestroyed) return;
                
                this.isDestroyed = true;
                this.cancelTargeting();
                
                if (this.element && this.element.parentNode) {
                    this.element.parentNode.removeChild(this.element);
                }
                
                // Remove from floatingMines array
                const index = floatingMines.indexOf(this);
                if (index > -1) {
                    floatingMines.splice(index, 1);
                }
            }
        }
        
        // Floating mine management functions
        function spawnFloatingMine() {
            if (!gameStarted) return;
            
            const mine = new FloatingMine();
            floatingMines.push(mine);
            
            console.log('Floating mine spawned. Total active:', floatingMines.length);
        }
        
        function startMineSpawning() {
            if (mineSpawnTimer) {
                clearInterval(mineSpawnTimer);
            }
            
            mineSpawnTimer = setInterval(() => {
                spawnFloatingMine();
            }, mineSpawnInterval);
            
            // Spawn first mine after 15 seconds
            setTimeout(() => {
                spawnFloatingMine();
            }, 15000);
        }
        
        function stopMineSpawning() {
            if (mineSpawnTimer) {
                clearInterval(mineSpawnTimer);
                mineSpawnTimer = null;
            }
            
            // Destroy all floating mines
            floatingMines.forEach(mine => mine.destroy());
            floatingMines = [];
        }
        
        function updateFloatingMines() {
            floatingMines.forEach(mine => {
                if (!mine.isDestroyed) {
                    mine.update();
                }
            });
        }
        
        function createCollectionSound() {
            // Create pleasant collection sound
            const osc1 = audioContext.createOscillator();
            const osc2 = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            osc1.connect(gainNode);
            osc2.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Pleasant ascending tones
            osc1.frequency.setValueAtTime(440, audioContext.currentTime);
            osc1.frequency.exponentialRampToValueAtTime(660, audioContext.currentTime + 0.2);
            
            osc2.frequency.setValueAtTime(880, audioContext.currentTime);
            osc2.frequency.exponentialRampToValueAtTime(1320, audioContext.currentTime + 0.2);
            
            gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
            
            osc1.start(audioContext.currentTime);
            osc2.start(audioContext.currentTime);
            osc1.stop(audioContext.currentTime + 0.3);
            osc2.stop(audioContext.currentTime + 0.3);
        }
        
        // Pulsar endgame mechanics
        function createPulsar() {
            if (pulsarElement) {
                pulsarElement.remove();
            }
            
            pulsarElement = document.createElement("div");
            pulsarElement.className = "pulsar";
            pulsarElement.style.left = (containerWidth / 2) + "px";
            pulsarElement.style.top = (containerHeight / 2) + "px";
            document.body.appendChild(pulsarElement);
        }
        
        function updatePulsarPhase() {
            const activeWordCount = floatingTexts.filter(text => !text.isDestroyed).length;
            
            if (activeWordCount <= 2 && pulsarPhase !== 2) {
                // Phase 2: Red pulsar for ≤2 words
                pulsarPhase = 2;
                pulsarCycleTime = 500; // 0.5 seconds
                pulsarTimer = 0;
                pulsarCycleCount = 0;
                
                if (!pulsarElement) {
                    createPulsar();
                }
                pulsarElement.className = "pulsar phase2";
                createPulsarWave("phase2");
                
            } else if (activeWordCount <= 4 && activeWordCount > 2 && pulsarPhase !== 1) {
                // Phase 1: Blue pulsar for ≤4 words (but >2)
                pulsarPhase = 1;
                pulsarCycleTime = 1000; // 1 second
                pulsarTimer = 0;
                pulsarCycleCount = 0;
                
                if (!pulsarElement) {
                    createPulsar();
                }
                pulsarElement.className = "pulsar phase1";
                createPulsarWave("phase1");
                
            } else if (activeWordCount > 4 && pulsarPhase !== 0) {
                // Deactivate pulsar
                pulsarPhase = 0;
                pulsarActive = false;
                if (pulsarElement) {
                    pulsarElement.remove();
                    pulsarElement = null;
                }
            }
        }
        
        function applyPulsarAttraction(deltaTime) {
            if (pulsarPhase === 0 || !pulsarActive) return;
            
            const centerX = containerWidth / 2;
            const centerY = containerHeight / 2;
            const baseForce = pulsarPhase === 1 ? 0.3 : 0.6; // Stronger in phase 2
            const timeMultiplier = Math.min(1 + (pulsarCycleCount * 0.1), 2.5); // Increase over time
            
            floatingTexts.forEach(text => {
                if (text.isDestroyed) return;
                
                const dx = centerX - text.x;
                const dy = centerY - text.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 5) { // Avoid division by zero and jitter at center
                    const force = (baseForce * timeMultiplier) / (distance * 0.01);
                    const forceX = (dx / distance) * force;
                    const forceY = (dy / distance) * force;
                    
                    text.vx += forceX * deltaTime * 0.001;
                    text.vy += forceY * deltaTime * 0.001;
                }
            });
        }
        
        function createPulsarWave(phase) {
            const wave = document.createElement("div");
            wave.className = "pulsar-wave " + phase;
            wave.style.left = (containerWidth / 2) + "px";
            wave.style.top = (containerHeight / 2) + "px";
            document.body.appendChild(wave);
            
            // Remove the wave after animation completes
            setTimeout(() => {
                if (wave.parentNode) {
                    wave.remove();
                }
            }, phase === "phase1" ? 1500 : 1000);
        }
        
        function resetPulsar() {
            pulsarPhase = 0;
            pulsarTimer = 0;
            pulsarCycleCount = 0;
            pulsarActive = false;
            
            if (pulsarElement) {
                pulsarElement.remove();
                pulsarElement = null;
            }
            
            // Remove any remaining waves
            document.querySelectorAll(".pulsar-wave").forEach(wave => wave.remove());
        }

        document.addEventListener('DOMContentLoaded', async function() {
            // Show info overlay on page load
            showInfoOverlay();
            
            function animate() {
                // Update des ersten Raumschiffs
                if (spaceshipController && gameStarted) {
                    spaceshipController.update();
                }
                
                // Update des zweiten Raumschiffs, falls es existiert
                if (secondSpaceshipController && gameStarted) {
                    secondSpaceshipController.update();
                }
                
                floatingTexts.forEach(text => {
                    if (!text.isDestroyed) {
                        text.update();
                    }
                });
                
                // Update der zielsuchenden Projektile
                if (gameStarted && activeProjectiles.length > 0) {
                    for (let i = activeProjectiles.length - 1; i >= 0; i--) {
                        const projectile = activeProjectiles[i];
                        if (!projectile.update(16)) {
                            activeProjectiles.splice(i, 1);
                        }
                    }
                }
                
                // Alle anderen Spiel-Updates
                if (gameStarted) {
                    updateBeacons();
                    updateFloatingMines();
                    updatePulsarPhase();
                    checkForSecondHunter(); // Prüft, ob der zweite Jäger gerufen werden soll

                    if (pulsarPhase > 0) {
                        pulsarTimer += 16;
                        if (pulsarTimer >= pulsarCycleTime) {
                            pulsarActive = !pulsarActive;
                            pulsarTimer = 0;
                            
                            if (pulsarActive) {
                                pulsarCycleCount++;
                                createPulsarWave(pulsarPhase === 1 ? "phase1" : "phase2");
                            }
                        }
                        if (pulsarActive) {
                            applyPulsarAttraction(16);
                        }
                    }
                }
                
                // NEU: Die zentrale Game-Over-Prüfung in jedem Frame
                checkForGameEnd();
                
                requestAnimationFrame(animate);
            }
            
            window.addEventListener('resize', () => {
                containerWidth = window.innerWidth;
                containerHeight = window.innerHeight;
                floatingTexts.forEach(text => {
                    if (!text.isDestroyed) {
                        text.resize();
                    }
                });
            });
            
            // Keyboard controls for shield system
            document.addEventListener('keydown', function(e) {
                if (e.code === 'Space' && gameStarted) {
                    e.preventDefault();
                    
                    if (shieldCount > 0) {
                        let targetedWord = null;
                        let threatSource = 'unbekannt';

                        // HÖCHSTE PRIORITÄT: Prüfe, ob eine zielsuchende Rakete aktiv ist.
                        if (activeProjectiles.length > 0) {
                            const activeHomingProjectile = activeProjectiles[0];
                            if (activeHomingProjectile && activeHomingProjectile.target && !activeHomingProjectile.target.isDestroyed) {
                                targetedWord = activeHomingProjectile.target;
                                threatSource = 'Ultraschuss-Rakete';
                            }
                        }
                        
                        // Wenn keine Rakete aktiv ist, prüfe die anderen Bedrohungen.
                        if (!targetedWord) {
                            // Prüfung der Minen (höhere Priorität als das Raumschiff selbst)
                            for (let mine of floatingMines) {
                                if (mine.isTargeting && mine.targetingWord) {
                                    targetedWord = mine.targetingWord;
                                    threatSource = 'Mobile Mine';
                                    break; 
                                }
                            }
                            if (!targetedWord) {
                                for (let beacon of spaceBeacons) {
                                    if (beacon.isTargeting && beacon.targetingWord) {
                                        targetedWord = beacon.targetingWord;
                                        threatSource = 'Statische Mine';
                                        break;
                                    }
                                }
                            }
                            // Letzte Priorität: Das Raumschiff, das gerade ein Ziel anvisiert.
                            if (!targetedWord && spaceshipController && spaceshipController.targetingWord) {
                                targetedWord = spaceshipController.targetingWord;
                                threatSource = 'Raumschiff';
                            }
                        }

                        // Wenn ein Ziel durch eine beliebige Bedrohung identifiziert wurde:
                        if (targetedWord) {
                            if (activateShield(targetedWord)) {
                                shieldCount--; // Schild erst hier verbrauchen.
                                console.log(`Schild aktiviert auf "${targetedWord.element.textContent}" gegen ${threatSource}. Verbleibend: ${shieldCount}`);
                            }
                        } else {
                            console.log('Schild-Einsatz nicht möglich: Keine aktive Bedrohung.');
                        }
                    } else {
                        console.log('Keine Schilde verfügbar.');
                    }
                }
            });
            
            animate();
        });
    </script>
</head>
<body>
    <div class="container">
        <!-- Space Background -->
        <svg class="space-background" width="100%" height="100%" style="position: absolute; top: 0; left: 0; z-index: 1; opacity: 1.0;">
            <defs>
                <radialGradient id="planet1" cx="50%" cy="50%" r="50%">
                    <stop offset="0%" style="stop-color:#ff6b6b;stop-opacity:1" />
                    <stop offset="70%" style="stop-color:#ee5a5a;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#d63031;stop-opacity:1" />
                </radialGradient>
                <radialGradient id="planet2" cx="30%" cy="30%" r="50%">
                    <stop offset="0%" style="stop-color:#74b9ff;stop-opacity:1" />
                    <stop offset="70%" style="stop-color:#0984e3;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#2d3436;stop-opacity:1" />
                </radialGradient>
                <radialGradient id="planet3" cx="40%" cy="20%" r="50%">
                    <stop offset="0%" style="stop-color:#a29bfe;stop-opacity:1" />
                    <stop offset="70%" style="stop-color:#6c5ce7;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#2d3436;stop-opacity:1" />
                </radialGradient>
                <radialGradient id="planet4" cx="60%" cy="40%" r="50%">
                    <stop offset="0%" style="stop-color:#ffeaa7;stop-opacity:1" />
                    <stop offset="70%" style="stop-color:#fdcb6e;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#e17055;stop-opacity:1" />
                </radialGradient>
                
                <!-- Comet Tail Gradients -->
                <linearGradient id="cometTail1" x1="0%" y1="0%" x2="100%" y2="0%">
                    <stop offset="0%" style="stop-color:#ffffff;stop-opacity:0.9" />
                    <stop offset="50%" style="stop-color:#74b9ff;stop-opacity:0.6" />
                    <stop offset="100%" style="stop-color:#74b9ff;stop-opacity:0" />
                </linearGradient>
                
                <linearGradient id="cometTail2" x1="0%" y1="0%" x2="100%" y2="0%">
                    <stop offset="0%" style="stop-color:#e8f4fd;stop-opacity:0.7" />
                    <stop offset="70%" style="stop-color:#74b9ff;stop-opacity:0.3" />
                    <stop offset="100%" style="stop-color:#0984e3;stop-opacity:0" />
                </linearGradient>
                
                <linearGradient id="cometTail3" x1="0%" y1="0%" x2="100%" y2="0%">
                    <stop offset="0%" style="stop-color:#ff4757;stop-opacity:0.9" />
                    <stop offset="50%" style="stop-color:#ff6b47;stop-opacity:0.6" />
                    <stop offset="100%" style="stop-color:#ff8a80;stop-opacity:0" />
                </linearGradient>
                
                <linearGradient id="cometTail4" x1="0%" y1="0%" x2="100%" y2="0%">
                    <stop offset="0%" style="stop-color:#00d2d3;stop-opacity:0.8" />
                    <stop offset="60%" style="stop-color:#55efc4;stop-opacity:0.4" />
                    <stop offset="100%" style="stop-color:#a7f3d0;stop-opacity:0" />
                </linearGradient>
                
                <linearGradient id="cometTail5" x1="0%" y1="0%" x2="100%" y2="0%">
                    <stop offset="0%" style="stop-color:#ffeaa7;stop-opacity:0.9" />
                    <stop offset="40%" style="stop-color:#fdcb6e;stop-opacity:0.7" />
                    <stop offset="100%" style="stop-color:#ffffff;stop-opacity:0" />
                </linearGradient>
                
                <linearGradient id="cometTail6" x1="0%" y1="0%" x2="100%" y2="0%">
                    <stop offset="0%" style="stop-color:#ffffff;stop-opacity:0.6" />
                    <stop offset="60%" style="stop-color:#ffeaa7;stop-opacity:0.3" />
                    <stop offset="100%" style="stop-color:#fdcb6e;stop-opacity:0" />
                </linearGradient>
            </defs>
            
            <!-- Stars with CSS Glow and Sparkle Effects -->
            <!-- Regular stars with subtle pulsing glow -->
            <circle cx="10%" cy="15%" r="2" fill="white" opacity="1" class="star-glow">
                <animate attributeName="opacity" values="0.7;1;0.7" dur="3.2s" repeatCount="indefinite"/>
            </circle>
            <circle cx="25%" cy="8%" r="3" fill="white" opacity="0.8" class="star-glow">
                <animate attributeName="opacity" values="0.6;0.8;0.6" dur="2.8s" repeatCount="indefinite"/>
            </circle>
            <circle cx="45%" cy="12%" r="2" fill="white" opacity="0.9" class="star-glow">
                <animate attributeName="opacity" values="0.7;0.9;0.7" dur="4.1s" repeatCount="indefinite"/>
            </circle>
            <circle cx="55%" cy="25%" r="2.5" fill="white" opacity="1"/>
            <circle cx="65%" cy="5%" r="1.8" fill="white" opacity="0.8"/>
            <circle cx="75%" cy="18%" r="3" fill="white" opacity="1" class="star-glow">
                <animate attributeName="opacity" values="0.8;1;0.8" dur="3.5s" repeatCount="indefinite"/>
            </circle>
            <circle cx="92%" cy="28%" r="1.5" fill="white" opacity="1"/>
            <circle cx="15%" cy="35%" r="2.2" fill="white" opacity="0.8" class="star-glow">
                <animate attributeName="opacity" values="0.6;0.8;0.6" dur="3.9s" repeatCount="indefinite"/>
            </circle>
            <circle cx="30%" cy="42%" r="1.8" fill="white" opacity="1"/>
            <circle cx="42%" cy="48%" r="2.5" fill="white" opacity="0.9"/>
            <circle cx="58%" cy="38%" r="2" fill="white" opacity="1" class="star-glow">
                <animate attributeName="opacity" values="0.8;1;0.8" dur="2.7s" repeatCount="indefinite"/>
            </circle>
            <circle cx="78%" cy="52%" r="2.5" fill="white" opacity="1"/>
            <circle cx="88%" cy="40%" r="2" fill="white" opacity="0.9" class="star-glow">
                <animate attributeName="opacity" values="0.7;0.9;0.7" dur="3.6s" repeatCount="indefinite"/>
            </circle>
            <circle cx="95%" cy="55%" r="1.8" fill="white" opacity="1"/>
            <circle cx="8%" cy="65%" r="3" fill="white" opacity="0.8"/>
            <circle cx="20%" cy="58%" r="2" fill="white" opacity="1" class="star-glow">
                <animate attributeName="opacity" values="0.8;1;0.8" dur="3.1s" repeatCount="indefinite"/>
            </circle>
            <circle cx="38%" cy="62%" r="1.5" fill="white" opacity="0.9"/>
            <circle cx="62%" cy="68%" r="2.5" fill="white" opacity="0.8" class="star-glow">
                <animate attributeName="opacity" values="0.6;0.8;0.6" dur="4.2s" repeatCount="indefinite"/>
            </circle>
            <circle cx="72%" cy="72%" r="1.8" fill="white" opacity="1"/>
            <circle cx="82%" cy="85%" r="2" fill="white" opacity="0.9"/>
            <circle cx="12%" cy="78%" r="2.5" fill="white" opacity="1" class="star-glow">
                <animate attributeName="opacity" values="0.8;1;0.8" dur="2.9s" repeatCount="indefinite"/>
            </circle>
            <circle cx="28%" cy="82%" r="1.5" fill="white" opacity="0.8"/>
            <circle cx="52%" cy="88%" r="2" fill="white" opacity="1"/>
            <circle cx="90%" cy="75%" r="2.2" fill="white" opacity="0.9"/>
            <circle cx="5%" cy="45%" r="1.8" fill="white" opacity="1"/>
            <circle cx="3%" cy="90%" r="2.5" fill="white" opacity="1"/>
            
            <!-- Special Sparkle Stars with Cross Effect -->
            <!-- Sparkle Star 1 - appears every 8 seconds -->
            <g opacity="0">
                <circle cx="35%" cy="22%" r="1.5" fill="white" class="star-sparkle"/>
                <!-- Cross sparkle lines -->
                <line x1="33%" y1="22%" x2="37%" y2="22%" stroke="white" stroke-width="0.8" opacity="0.8" class="star-sparkle"/>
                <line x1="35%" y1="20%" x2="35%" y2="24%" stroke="white" stroke-width="0.8" opacity="0.8" class="star-sparkle"/>
                <animate attributeName="opacity" values="0;0;0;1;0.8;1;0;0;0" dur="8s" repeatCount="indefinite"/>
            </g>
            
            <!-- Sparkle Star 2 - appears every 12 seconds with offset -->
            <g opacity="0">
                <circle cx="68%" cy="45%" r="1.5" fill="white" class="star-sparkle"/>
                <!-- Cross sparkle lines -->
                <line x1="66%" y1="45%" x2="70%" y2="45%" stroke="white" stroke-width="0.8" opacity="0.8" class="star-sparkle"/>
                <line x1="68%" y1="43%" x2="68%" y2="47%" stroke="white" stroke-width="0.8" opacity="0.8" class="star-sparkle"/>
                <animate attributeName="opacity" values="0;0;0;0;0;1;0.8;1;0;0;0;0" dur="12s" repeatCount="indefinite"/>
            </g>
            
            <!-- Sparkle Star 3 - appears every 15 seconds -->
            <g opacity="0">
                <circle cx="85%" cy="10%" r="2" fill="white" class="star-sparkle"/>
                <!-- Cross sparkle lines -->
                <line x1="83%" y1="10%" x2="87%" y2="10%" stroke="white" stroke-width="0.8" opacity="0.8" class="star-sparkle"/>
                <line x1="85%" y1="8%" x2="85%" y2="12%" stroke="white" stroke-width="0.8" opacity="0.8" class="star-sparkle"/>
                <animate attributeName="opacity" values="0;0;0;0;0;0;1;0.8;1;0;0;0;0;0;0" dur="15s" repeatCount="indefinite"/>
            </g>
            
            <!-- Sparkle Star 4 - appears every 10 seconds -->
            <g opacity="0">
                <circle cx="48%" cy="75%" r="2.2" fill="white" class="star-sparkle"/>
                <!-- Cross sparkle lines -->
                <line x1="46%" y1="75%" x2="50%" y2="75%" stroke="white" stroke-width="0.8" opacity="0.8" class="star-sparkle"/>
                <line x1="48%" y1="73%" x2="48%" y2="77%" stroke="white" stroke-width="0.8" opacity="0.8" class="star-sparkle"/>
                <animate attributeName="opacity" values="0;0;0;0;1;0.8;1;0;0;0" dur="10s" repeatCount="indefinite"/>
            </g>
            
            <!-- Sparkle Star 5 - appears every 18 seconds -->
            <g opacity="0">
                <circle cx="97%" cy="20%" r="2" fill="white" class="star-sparkle"/>
                <!-- Cross sparkle lines -->
                <line x1="95%" y1="20%" x2="99%" y2="20%" stroke="white" stroke-width="0.8" opacity="0.8" class="star-sparkle"/>
                <line x1="97%" y1="18%" x2="97%" y2="22%" stroke="white" stroke-width="0.8" opacity="0.8" class="star-sparkle"/>
                <animate attributeName="opacity" values="0;0;0;0;0;0;0;0;1;0.8;1;0;0;0;0;0;0;0" dur="18s" repeatCount="indefinite"/>
            </g>
            
            <!-- Planets -->
            <circle cx="85%" cy="15%" r="25" fill="url(#planet1)"/>
            <circle cx="12%" cy="25%" r="18" fill="url(#planet2)"/>
            <circle cx="20%" cy="85%" r="22" fill="url(#planet3)"/>
            <circle cx="90%" cy="80%" r="15" fill="url(#planet4)"/>
            
            <!-- Planet details (surface features) -->
            <circle cx="85%" cy="15%" r="25" fill="none" stroke="#d63031" stroke-width="0.5" opacity="0.3"/>
            <circle cx="82%" cy="12%" r="3" fill="#2d3436" opacity="0.4"/>
            <circle cx="88%" cy="18%" r="2" fill="#2d3436" opacity="0.3"/>
            
            <circle cx="12%" cy="25%" r="18" fill="none" stroke="#0984e3" stroke-width="0.5" opacity="0.3"/>
            <circle cx="10%" cy="23%" r="2" fill="#2d3436" opacity="0.4"/>
            <circle cx="14%" cy="27%" r="1.5" fill="#2d3436" opacity="0.3"/>
            
            <circle cx="20%" cy="85%" r="22" fill="none" stroke="#6c5ce7" stroke-width="0.5" opacity="0.3"/>
            <circle cx="18%" cy="82%" r="2.5" fill="#2d3436" opacity="0.4"/>
            <circle cx="22%" cy="87%" r="1.8" fill="#2d3436" opacity="0.3"/>
            
            <circle cx="90%" cy="80%" r="15" fill="none" stroke="#e17055" stroke-width="0.5" opacity="0.3"/>
            <circle cx="88%" cy="78%" r="1.5" fill="#2d3436" opacity="0.4"/>
            <circle cx="92%" cy="82%" r="1" fill="#2d3436" opacity="0.3"/>
            
            <!-- Great A'Tuin (Discworld Turtle) - Profile View -->
            <g id="great-atuin" opacity="0.7">
                <!-- Shell (profile view) -->
                <path d="M -60 -10 Q -65 -25 -45 -30 Q -15 -35 15 -30 Q 45 -25 50 -10 Q 55 0 50 10 Q 45 25 15 30 Q -15 35 -45 30 Q -65 25 -60 10 Z" 
                      fill="#2d5a3d" stroke="#1a3d26" stroke-width="2"/>
                
                <!-- Shell segments -->
                <path d="M -45 -25 Q -20 -30 0 -25 Q 20 -30 40 -25" fill="none" stroke="#1a3d26" stroke-width="1"/>
                <path d="M -40 -10 Q -15 -15 5 -10 Q 25 -15 45 -10" fill="none" stroke="#1a3d26" stroke-width="1"/>
                <path d="M -40 5 Q -15 0 5 5 Q 25 0 45 5" fill="none" stroke="#1a3d26" stroke-width="1"/>
                <path d="M -45 20 Q -20 25 0 20 Q 20 25 40 20" fill="none" stroke="#1a3d26" stroke-width="1"/>
                
                <!-- Head (extended forward) -->
                <ellipse cx="-75" cy="0" rx="15" ry="12" fill="#3d6b4a" stroke="#1a3d26" stroke-width="1"/>
                <!-- Eye -->
                <circle cx="-82" cy="-3" r="3" fill="#ffff88" stroke="#000" stroke-width="0.5"/>
                <circle cx="-82" cy="-3" r="1.5" fill="#000"/>
                
                <!-- Front legs -->
                <ellipse cx="-50" cy="25" rx="8" ry="15" fill="#3d6b4a" stroke="#1a3d26" stroke-width="1"/>
                <ellipse cx="-25" cy="30" rx="6" ry="12" fill="#3d6b4a" stroke="#1a3d26" stroke-width="1"/>
                
                <!-- Back legs -->
                <ellipse cx="20" cy="30" rx="6" ry="12" fill="#3d6b4a" stroke="#1a3d26" stroke-width="1"/>
                <ellipse cx="40" cy="25" rx="8" ry="15" fill="#3d6b4a" stroke="#1a3d26" stroke-width="1"/>
                
                <!-- Tail -->
                <ellipse cx="65" cy="5" rx="8" ry="6" fill="#3d6b4a" stroke="#1a3d26" stroke-width="1"/>
                
                <!-- The Four Elephants standing on the shell -->
                <!-- Elephant 1 (leftmost) -->
                <g transform="translate(-35, -35)">
                    <ellipse cx="0" cy="0" rx="8" ry="6" fill="#8B7355" stroke="#654321" stroke-width="0.8"/>
                    <circle cx="0" cy="-8" r="4" fill="#8B7355" stroke="#654321" stroke-width="0.8"/>
                    <ellipse cx="-3" cy="-10" rx="1" ry="3" fill="#8B7355"/>
                    <ellipse cx="3" cy="-10" rx="1" ry="3" fill="#8B7355"/>
                    <circle cx="-2" cy="-9" r="0.8" fill="#000"/>
                    <rect x="-6" y="6" width="2" height="8" fill="#8B7355"/>
                    <rect x="-2" y="6" width="2" height="8" fill="#8B7355"/>
                    <rect x="2" y="6" width="2" height="8" fill="#8B7355"/>
                    <rect x="6" y="6" width="2" height="8" fill="#8B7355"/>
                </g>
                
                <!-- Elephant 2 -->
                <g transform="translate(-10, -35)">
                    <ellipse cx="0" cy="0" rx="8" ry="6" fill="#8B7355" stroke="#654321" stroke-width="0.8"/>
                    <circle cx="0" cy="-8" r="4" fill="#8B7355" stroke="#654321" stroke-width="0.8"/>
                    <ellipse cx="-3" cy="-10" rx="1" ry="3" fill="#8B7355"/>
                    <ellipse cx="3" cy="-10" rx="1" ry="3" fill="#8B7355"/>
                    <circle cx="-2" cy="-9" r="0.8" fill="#000"/>
                    <rect x="-6" y="6" width="2" height="8" fill="#8B7355"/>
                    <rect x="-2" y="6" width="2" height="8" fill="#8B7355"/>
                    <rect x="2" y="6" width="2" height="8" fill="#8B7355"/>
                    <rect x="6" y="6" width="2" height="8" fill="#8B7355"/>
                </g>
                
                <!-- Elephant 3 -->
                <g transform="translate(15, -35)">
                    <ellipse cx="0" cy="0" rx="8" ry="6" fill="#8B7355" stroke="#654321" stroke-width="0.8"/>
                    <circle cx="0" cy="-8" r="4" fill="#8B7355" stroke="#654321" stroke-width="0.8"/>
                    <ellipse cx="-3" cy="-10" rx="1" ry="3" fill="#8B7355"/>
                    <ellipse cx="3" cy="-10" rx="1" ry="3" fill="#8B7355"/>
                    <circle cx="-2" cy="-9" r="0.8" fill="#000"/>
                    <rect x="-6" y="6" width="2" height="8" fill="#8B7355"/>
                    <rect x="-2" y="6" width="2" height="8" fill="#8B7355"/>
                    <rect x="2" y="6" width="2" height="8" fill="#8B7355"/>
                    <rect x="6" y="6" width="2" height="8" fill="#8B7355"/>
                </g>
                
                <!-- Elephant 4 (rightmost) -->
                <g transform="translate(40, -35)">
                    <ellipse cx="0" cy="0" rx="8" ry="6" fill="#8B7355" stroke="#654321" stroke-width="0.8"/>
                    <circle cx="0" cy="-8" r="4" fill="#8B7355" stroke="#654321" stroke-width="0.8"/>
                    <ellipse cx="-3" cy="-10" rx="1" ry="3" fill="#8B7355"/>
                    <ellipse cx="3" cy="-10" rx="1" ry="3" fill="#8B7355"/>
                    <circle cx="-2" cy="-9" r="0.8" fill="#000"/>
                    <rect x="-6" y="6" width="2" height="8" fill="#8B7355"/>
                    <rect x="-2" y="6" width="2" height="8" fill="#8B7355"/>
                    <rect x="2" y="6" width="2" height="8" fill="#8B7355"/>
                    <rect x="6" y="6" width="2" height="8" fill="#8B7355"/>
                </g>
                
                <animateTransform
                    attributeName="transform"
                    type="translate"
                    values="-150,400; 1200,300; -150,200"
                    dur="60s"
                    repeatCount="indefinite"/>
            </g>
            
            <!-- Alien Ships -->
            <!-- Alien Ship 1 - Classic Saucer -->
            <g id="alien-ship-1" opacity="0.8">
                <ellipse cx="0" cy="0" rx="25" ry="8" fill="#4a9eff" stroke="#2980b9" stroke-width="1"/>
                <ellipse cx="0" cy="-3" rx="15" ry="6" fill="#74b9ff" stroke="#0984e3" stroke-width="0.5"/>
                <circle cx="0" cy="-3" r="8" fill="#a8e6cf" opacity="0.7"/>
                <!-- Lights -->
                <circle cx="-15" cy="0" r="2" fill="#ff6b6b" opacity="0.9">
                    <animate attributeName="opacity" values="0.9;0.3;0.9" dur="1.5s" repeatCount="indefinite"/>
                </circle>
                <circle cx="0" cy="0" r="2" fill="#ffd93d" opacity="0.9">
                    <animate attributeName="opacity" values="0.3;0.9;0.3" dur="1.8s" repeatCount="indefinite"/>
                </circle>
                <circle cx="15" cy="0" r="2" fill="#6c5ce7" opacity="0.9">
                    <animate attributeName="opacity" values="0.9;0.3;0.9" dur="1.2s" repeatCount="indefinite"/>
                </circle>
                
                <animateTransform
                    attributeName="transform"
                    type="translate"
                    values="1100,150; -100,350; 1100,100"
                    dur="35s"
                    repeatCount="indefinite"/>
            </g>
            
            <!-- Alien Ship 2 - Triangular -->
            <g id="alien-ship-2" opacity="0.8">
                <polygon points="0,-15 -20,10 20,10" fill="#e17055" stroke="#d63031" stroke-width="1"/>
                <polygon points="0,-8 -12,5 12,5" fill="#ff7675" stroke="#e84393" stroke-width="0.5"/>
                <circle cx="0" cy="-2" r="4" fill="#00cec9" opacity="0.8"/>
                <!-- Energy trails -->
                <circle cx="-10" cy="8" r="1.5" fill="#74b9ff" opacity="0.6">
                    <animate attributeName="opacity" values="0.6;0.1;0.6" dur="0.8s" repeatCount="indefinite"/>
                </circle>
                <circle cx="10" cy="8" r="1.5" fill="#74b9ff" opacity="0.6">
                    <animate attributeName="opacity" values="0.1;0.6;0.1" dur="0.8s" repeatCount="indefinite"/>
                </circle>
                
                <animateTransform
                    attributeName="transform"
                    type="translate"
                    values="-80,500; 1100,250; -80,80"
                    dur="40s"
                    repeatCount="indefinite"/>
            </g>
            
            <!-- Alien Ship 3 - Cylindrical -->
            <g id="alien-ship-3" opacity="0.8">
                <rect x="-20" y="-6" width="40" height="12" fill="#a29bfe" stroke="#6c5ce7" stroke-width="1" rx="6"/>
                <ellipse cx="-15" cy="0" rx="3" ry="8" fill="#fd79a8" opacity="0.7"/>
                <ellipse cx="15" cy="0" rx="3" ry="8" fill="#fd79a8" opacity="0.7"/>
                <circle cx="0" cy="0" r="5" fill="#55efc4" opacity="0.8">
                    <animate attributeName="r" values="5;7;5" dur="2s" repeatCount="indefinite"/>
                </circle>
                <!-- Exhaust -->
                <ellipse cx="-25" cy="0" rx="4" ry="2" fill="#ff6348" opacity="0.6">
                    <animate attributeName="opacity" values="0.6;0.2;0.6" dur="0.5s" repeatCount="indefinite"/>
                </ellipse>
                
                <animateTransform
                    attributeName="transform"
                    type="translate"
                    values="1100,450; -100,180; 1100,300"
                    dur="50s"
                    repeatCount="indefinite"/>
            </g>
            
            <!-- Only 2 Realistic Comets with Correct Trailing Tails -->
            <!-- Ice Comet - moves right, tail trails left behind -->
            <g id="ice-comet" opacity="0.8">
                <!-- Comet nucleus (at the front) -->
                <ellipse cx="0" cy="0" rx="4" ry="6" fill="#e8f4fd" stroke="#74b9ff" stroke-width="0.5">
                    <animate attributeName="fill" values="#e8f4fd;#ffffff;#e8f4fd" dur="1.5s" repeatCount="indefinite"/>
                </ellipse>
                
                <!-- Main tail (trails behind as comet moves right) -->
                <path d="M -5 0 Q -35 -3 -65 -5 Q -95 -7 -125 -9" 
                      stroke="url(#cometTail1)" stroke-width="8" fill="none" opacity="0.7">
                    <animate attributeName="opacity" values="0.7;0.3;0.7" dur="2s" repeatCount="indefinite"/>
                </path>
                
                <!-- Secondary tail -->
                <path d="M -3 0 Q -28 2 -53 4 Q -78 6 -103 8" 
                      stroke="url(#cometTail2)" stroke-width="4" fill="none" opacity="0.5">
                    <animate attributeName="opacity" values="0.5;0.2;0.5" dur="1.8s" repeatCount="indefinite"/>
                </path>
                
                <!-- Particle trail (behind movement) -->
                <circle cx="-15" cy="-1" r="1" fill="#ffffff" opacity="0.8">
                    <animate attributeName="opacity" values="0.8;0.2;0.8" dur="0.8s" repeatCount="indefinite"/>
                </circle>
                <circle cx="-30" cy="-2" r="0.8" fill="#74b9ff" opacity="0.6">
                    <animate attributeName="opacity" values="0.6;0.1;0.6" dur="1.2s" repeatCount="indefinite"/>
                </circle>
                <circle cx="-50" cy="-3" r="0.6" fill="#ffffff" opacity="0.4">
                    <animate attributeName="opacity" values="0.4;0.1;0.4" dur="1.5s" repeatCount="indefinite"/>
                </circle>
                
                <animateTransform
                    attributeName="transform"
                    type="translate"
                    values="-150,150; 1200,350; 1300,400"
                    dur="22s"
                    repeatCount="indefinite"/>
            </g>
            
            <!-- Fire Comet - moves down-left, tail trails up-right behind -->
            <g id="fire-comet" opacity="0.7">
                <!-- Comet nucleus (at the front) -->
                <ellipse cx="0" cy="0" rx="5" ry="7" fill="#ff6b47" stroke="#ff4757" stroke-width="1">
                    <animate attributeName="fill" values="#ff6b47;#ff3838;#ff6b47" dur="1.2s" repeatCount="indefinite"/>
                </ellipse>
                
                <!-- Inner glow -->
                <ellipse cx="0" cy="0" rx="8" ry="10" fill="#ff6b47" opacity="0.3">
                    <animate attributeName="opacity" values="0.3;0.5;0.3" dur="1s" repeatCount="indefinite"/>
                </ellipse>
                
                <!-- Main tail (trails opposite to movement direction) -->
                <path d="M 3 -3 Q 33 -23 63 -43 Q 93 -63 123 -83" 
                      stroke="url(#cometTail3)" stroke-width="10" fill="none" opacity="0.8">
                    <animate attributeName="opacity" values="0.8;0.4;0.8" dur="1.8s" repeatCount="indefinite"/>
                </path>
                
                <!-- Fire particles (behind movement) -->
                <circle cx="15" cy="-10" r="1.5" fill="#ff4757" opacity="0.7">
                    <animate attributeName="opacity" values="0.7;0.2;0.7" dur="0.6s" repeatCount="indefinite"/>
                </circle>
                <circle cx="30" cy="-20" r="1.2" fill="#ff6b47" opacity="0.5">
                    <animate attributeName="opacity" values="0.5;0.1;0.5" dur="0.9s" repeatCount="indefinite"/>
                </circle>
                <circle cx="50" cy="-35" r="1" fill="#ff8a80" opacity="0.3">
                    <animate attributeName="opacity" values="0.3;0.08;0.3" dur="1.2s" repeatCount="indefinite"/>
                </circle>
                
                <animateTransform
                    attributeName="transform"
                    type="translate"
                    values="1200,100; -200,500; -250,550"
                    dur="28s"
                    repeatCount="indefinite"/>
            </g>
            
            <!-- Fire Comet - Orange-red with intense glow -->
            <g id="fire-comet" opacity="0.8">
                <!-- Comet nucleus -->
                <ellipse cx="0" cy="0" rx="5" ry="7" fill="#ff6b47" stroke="#ff4757" stroke-width="1">
                    <animate attributeName="fill" values="#ff6b47;#ff3838;#ff6b47" dur="1.2s" repeatCount="indefinite"/>
                </ellipse>
                
                <!-- Inner glow -->
                <ellipse cx="0" cy="0" rx="8" ry="10" fill="#ff6b47" opacity="0.3">
                    <animate attributeName="opacity" values="0.3;0.6;0.3" dur="1s" repeatCount="indefinite"/>
                </ellipse>
                
                <!-- Main tail -->
                <path d="M 0 0 Q -40 -3 -80 -5 Q -120 -6 -160 -8" 
                      stroke="url(#cometTail3)" stroke-width="10" fill="none" opacity="0.9">
                    <animate attributeName="opacity" values="0.9;0.5;0.9" dur="1.8s" repeatCount="indefinite"/>
                </path>
                
                <!-- Fire particles -->
                <circle cx="-15" cy="-1" r="1.5" fill="#ff4757" opacity="0.8">
                    <animate attributeName="opacity" values="0.8;0.2;0.8" dur="0.6s" repeatCount="indefinite"/>
                </circle>
                <circle cx="-30" cy="-2" r="1.2" fill="#ff6b47" opacity="0.6">
                    <animate attributeName="opacity" values="0.6;0.1;0.6" dur="0.9s" repeatCount="indefinite"/>
                </circle>
                <circle cx="-50" cy="-3" r="1" fill="#ff8a80" opacity="0.4">
                    <animate attributeName="opacity" values="0.4;0.08;0.4" dur="1.2s" repeatCount="indefinite"/>
                </circle>
                <circle cx="-80" cy="-4" r="0.8" fill="#ff4757" opacity="0.3">
                    <animate attributeName="opacity" values="0.3;0.05;0.3" dur="1.5s" repeatCount="indefinite"/>
                </circle>
                
                <animateTransform
                    attributeName="transform"
                    type="translate"
                    values="1200,50; -150,400; -200,450"
                    dur="30s"
                    repeatCount="indefinite"/>
            </g>
            
            <!-- Rare Green Comet - Mystical emerald -->
            <g id="green-comet" opacity="0.7">
                <!-- Comet nucleus -->
                <ellipse cx="0" cy="0" rx="3" ry="5" fill="#00d2d3" stroke="#01a3a4" stroke-width="0.8">
                    <animate attributeName="fill" values="#00d2d3;#55efc4;#00d2d3" dur="2s" repeatCount="indefinite"/>
                </ellipse>
                
                <!-- Mystical glow -->
                <ellipse cx="0" cy="0" rx="6" ry="8" fill="#55efc4" opacity="0.4">
                    <animate attributeName="opacity" values="0.4;0.7;0.4" dur="2.5s" repeatCount="indefinite"/>
                </ellipse>
                
                <!-- Main tail -->
                <path d="M 0 0 Q -35 4 -70 8 Q -105 12 -140 16" 
                      stroke="url(#cometTail4)" stroke-width="6" fill="none" opacity="0.7">
                    <animate attributeName="opacity" values="0.7;0.3;0.7" dur="2.2s" repeatCount="indefinite"/>
                </path>
                
                <!-- Magical particles -->
                <circle cx="-18" cy="2" r="0.8" fill="#55efc4" opacity="0.8">
                    <animate attributeName="opacity" values="0.8;0.2;0.8" dur="1.4s" repeatCount="indefinite"/>
                </circle>
                <circle cx="-40" cy="4" r="0.6" fill="#00d2d3" opacity="0.6">
                    <animate attributeName="opacity" values="0.6;0.1;0.6" dur="1.8s" repeatCount="indefinite"/>
                </circle>
                <circle cx="-65" cy="6" r="0.4" fill="#a7f3d0" opacity="0.4">
                    <animate attributeName="opacity" values="0.4;0.08;0.4" dur="2.1s" repeatCount="indefinite"/>
                </circle>
                
                <animateTransform
                    attributeName="transform"
                    type="translate"
                    values="100,-50; 800,600; 900,700"
                    dur="45s"
                    repeatCount="indefinite"/>
            </g>
            
            <!-- Mega Comet - Rare spectacular giant -->
            <g id="mega-comet" opacity="0.6">
                <!-- Large nucleus -->
                <ellipse cx="0" cy="0" rx="8" ry="12" fill="#ffeaa7" stroke="#fdcb6e" stroke-width="2">
                    <animate attributeName="fill" values="#ffeaa7;#ffffff;#ffeaa7" dur="1.8s" repeatCount="indefinite"/>
                </ellipse>
                
                <!-- Massive glow -->
                <ellipse cx="0" cy="0" rx="15" ry="20" fill="#ffeaa7" opacity="0.3">
                    <animate attributeName="opacity" values="0.3;0.6;0.3" dur="2s" repeatCount="indefinite"/>
                </ellipse>
                
                <!-- Enormous tail -->
                <path d="M 0 0 Q -60 -8 -120 -15 Q -180 -20 -240 -25" 
                      stroke="url(#cometTail5)" stroke-width="15" fill="none" opacity="0.8">
                    <animate attributeName="opacity" values="0.8;0.4;0.8" dur="2.5s" repeatCount="indefinite"/>
                </path>
                
                <!-- Secondary massive tail -->
                <path d="M 0 0 Q -50 5 -100 10 Q -150 15 -200 20" 
                      stroke="url(#cometTail6)" stroke-width="8" fill="none" opacity="0.6">
                    <animate attributeName="opacity" values="0.6;0.2;0.6" dur="2.2s" repeatCount="indefinite"/>
                </path>
                
                <!-- Giant particles -->
                <circle cx="-25" cy="-3" r="2" fill="#ffffff" opacity="0.9">
                    <animate attributeName="opacity" values="0.9;0.3;0.9" dur="1s" repeatCount="indefinite"/>
                </circle>
                <circle cx="-60" cy="-8" r="1.5" fill="#ffeaa7" opacity="0.7">
                    <animate attributeName="opacity" values="0.7;0.2;0.7" dur="1.3s" repeatCount="indefinite"/>
                </circle>
                <circle cx="-100" cy="-12" r="1.2" fill="#fdcb6e" opacity="0.5">
                    <animate attributeName="opacity" values="0.5;0.1;0.5" dur="1.6s" repeatCount="indefinite"/>
                </circle>
                <circle cx="-150" cy="-18" r="1" fill="#ffffff" opacity="0.3">
                    <animate attributeName="opacity" values="0.3;0.05;0.3" dur="2s" repeatCount="indefinite"/>
                </circle>
                
                <animateTransform
                    attributeName="transform"
                    type="translate"
                    values="1300,200; -300,500; -400,600"
                    dur="60s"
                    repeatCount="indefinite"/>
            </g>
        </svg>
        
        <!-- Words will be loaded dynamically from words.json -->
    </div>
</body>
</html>